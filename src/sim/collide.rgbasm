include "collide.rgbinc"
include "coord.rgbinc"


section "wCollideBounds", wram0
;; World boundary
wCollideBounds::
	.xpos:: dw
	.xend:: dw
	.ypos:: dw
	.yend:: dw


section "wCollide", wram0
wCollidePose:
	.spx: dw
	.cellx: db
	.gridx: db
	.spy: dw
	.celly: db
	.gridy: db


section "hCollide", hram
hCollide::
	;; Query point, X coord
	.px:: dw
	;; Query point, Y coord
	.py:: dw
	;; X motion step, (signed 4.4 Coord)
	.vx:: db
	;; Y motion step, (signed 4.4 Coord)
	.vy:: db
	;; Query result flags
	.result:: db


section "Collide", rom0
CollideInit::
	ld hl, startof("hCollide")
	ld c, sizeof("hCollide")
	ld a, $FF
	call MemFillSmall
	xor a :: ldh [hCollide.result], a

	ld hl, wCollideBounds
	xor a :: ld [hl+], a :: ld [hl+], a
	ld a, $FF :: ld [hl+], a
	xor a :: ld [hl+], a :: ld [hl+], a
	ld a, $FF :: ld [hl+], a

	ld hl, startof("wCollide")
	ld c, sizeof("wCollide")
	xor a
	call MemFillSmall

	ld hl, wCollideBounds.xpos
	coord_ld_hli_int (WORLD_ORIGIN >> 4) + 0
	coord_ld_hli_int (WORLD_ORIGIN >> 4) + 2000
	ld hl, wCollideBounds.ypos
	coord_ld_hli_int (WORLD_ORIGIN >> 4) + 0
	coord_ld_hli_int (WORLD_ORIGIN >> 4) + 2000

	ret


;; Execute the configured query
;; @mut: AF, BC, DE, HL
CollidePointMotion::
	call __QueryBegin
	call __QueryPointMotion
	call __QueryEnd
	jp CollideWorldBounds


;; Initial setup of query working struct
__QueryBegin:
	ld hl, wCollidePose.spx
	ldh a, [hCollide.px+0] :: ld c, a
	ldh a, [hCollide.px+1] :: ld b, a
	call __QuerySetPosition

	ld hl, wCollidePose.spy
	ldh a, [hCollide.py+0] :: ld c, a
	ldh a, [hCollide.py+1] :: ld b, a
	call __QuerySetPosition

	xor a :: ldh [hCollide.result], a

	ret


;; Finalise results from query struct
__QueryEnd:
	ld hl, wCollidePose.spx
	ld a, [hl+] :: ldh [hCollide.px+0], a
	ld a, [hl+] :: ldh [hCollide.px+1], a

	ld hl, wCollidePose.spy
	ld a, [hl+] :: ldh [hCollide.py+0], a
	ld a, [hl+] :: ldh [hCollide.py+1], a
	ret


;; Apply step to position and update query.
;; @param HL: pointer to query pose
;; @param E: step
;; @ret BC: updated position
;; @ret D: grid position
;; @ret E: cell local position
;; @mut: AF, BC, DE, HL
__QueryApplyStep:
	ld a, [hl+] :: ld c, a
	ld a, [hl-] :: ld b, a

	; Update position (16 bit + signed 8 bit)
	ld a, e
	add c
	ld c, a
	adc b
	rl e ; Set F.C from sign of velocity
	sbc c
	ld b, a


	; FALLTHROUGH


;; Update query pose. Position is used as-is and used to calculate the remaining fields.
;; @param BC: position
;; @param HL: this
;; @ret D: grid position
;; @ret E: cell local position
__QuerySetPosition:
	ld a, c :: ld [hl+], a
	ld a, b :: ld [hl+], a
	; PointToGrid
	ld a, c :: and $7F :: ld e, a
	ld [hl+], a
	ld a, c :: rla
	ld a, b :: rla
	and $1F :: ld d, a
	ld [hl+], a
	ret


__QueryPointMotion:
	; X axis
	ldh a, [hCollide.vx]
	and a
jr z, .x_axis_end
	ld e, a

	ld hl, wCollidePose.spx
	call __QueryApplyStep
	ld c, e :: ld e, d

	ld hl, wCollidePose.celly
	ld a, [hl+] :: ld b, a
	ld a, [hl+] :: ld d, a ; gridy

	call _BgTileLookup
	call CollidePointInTile_enviro0
	; do ejection if eject delta is nonzero and opposes step direction
	ld a, e
	and a
jr z, .x_axis_end
	ldh a, [hCollide.vx]
	xor e
	rla
jr nc, .x_axis_end
	ldh a, [hCollide.result]
	or CollideResult_SOLID|CollideResult_X
	ldh [hCollide.result], a

	ld hl, wCollidePose.spx
	call __QueryApplyStep
.x_axis_end

	; Y axis
	ldh a, [hCollide.vy]
	and a
jr z, .y_axis_end
	ld e, a

	ld hl, wCollidePose.spy
	call __QueryApplyStep
	ld b, e

	ld hl, wCollidePose.cellx
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld e, a ; gridx

	call _BgTileLookup
	call CollidePointInTile_enviro0
	; do ejection if eject delta is nonzero and opposes step direction
	ld a, d
	and a
jr z, .y_axis_end
	ldh a, [hCollide.vy]
	xor d
	rla
jr nc, .y_axis_end
	ldh a, [hCollide.result]
	or CollideResult_SOLID|CollideResult_Y
	ldh [hCollide.result], a

	ld e, d ; Y eject
	ld hl, wCollidePose.spy
	call __QueryApplyStep
.y_axis_end

	ret


;; TODO: This should probably be handled by Map.
;; @param D,E: Y,X grid coord (mod 32)
;; @ret A: BG Map tile ID
;; @ret HL: pointer to BG Map cell
;; @mut: AF, HL
_BgTileLookup:
	; (Y mod 32) * 32
	ld a, d
;	and $1F ; mod 32
	add a :: add a :: add a ; Y * 8
	ld l, a
	ld h, 0
	add hl, hl :: add hl, hl ; * 32
	; ... + (X mod 32)
	ld a, e
;	and $1F ; mod 32
	add l
	ld l, a
	adc h
	sub l
	add high(wMapBgChr)
	ld h, a
	ld a, [hl]

	ret


CollideWorldBounds:
	ldh a, [hCollide.px+0] :: ld c, a
	ldh a, [hCollide.px+1] :: ld b, a
	ld hl, wCollideBounds.xpos
	call CollidePointOutRange
	jr nc, :+
	ld a, e :: ldh [hCollide.px+0], a
	ld a, d :: ldh [hCollide.px+1], a
	ldh a, [hCollide.result]
	or CollideResult_X|CollideResult_SOLID
	ldh [hCollide.result], a
:
	ldh a, [hCollide.py+0] :: ld c, a
	ldh a, [hCollide.py+1] :: ld b, a
	ld hl, wCollideBounds.ypos
	call CollidePointOutRange
	jr nc, :+
	ld a, e :: ldh [hCollide.py+0], a
	ld a, d :: ldh [hCollide.py+1], a
	ldh a, [hCollide.result]
	or CollideResult_Y|CollideResult_SOLID
	ldh [hCollide.result], a
:
	ret


;; Point out of range
;; @param HL: collider range ({pos,end}})
;; @param BC: query point coord
;; @ret DE: position on boundary exceeded (if F.C)
;; @ret F.C: result
;; @mut: AF, DE, HL
CollidePointOutRange:
	ld a, [hl+] :: ld e, a
	ld a, [hl+] :: ld d, a
	call CoordCompare_BC_DE
	ret c

	ld a, [hl+] :: ld e, a
	ld a, [hl+] :: ld d, a
	call CoordCompare_DE_BC
	ret

