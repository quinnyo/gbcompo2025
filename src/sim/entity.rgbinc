if !def(Q_ENTITY_INC_b4moRE1M)
def Q_ENTITY_INC_b4moRE1M equ 1


def ENTITY_COUNT_MAX equ 16
def ENTITY_AUTO_ASSIGN_START equ 4

def GRAVITY_DEFAULT equ $0_4

def SIM_GRAVITY_TICK equ $07

;; Number of shifts (divide by 2) used to scale velocity
def DRAGTAB_INPUT_DIVS equ 3

def SPEED_LIMIT equ 30
def SPEED_RANGE_LO equ SPEED_LIMIT
def SPEED_RANGE_HI equ 256 - SPEED_LIMIT
def SPEED_RANGE_CLAMP_PARAM equ $8080 ^ ((SPEED_RANGE_HI << 8) | SPEED_RANGE_LO)

;; Y axis adjustment offset for placing Entity sprites
def ENT_SPRITE_Y_OFF equ 0
;; X axis adjustment offset for placing Entity sprites
def ENT_SPRITE_X_OFF equ 0

def szEntity_Info    equ 1
def szEntity_Ctrl    equ 1
def szEntity_AccX    equ 1
def szEntity_VelX    equ 1
def szEntity_PosX    equ 2
def szEntity_AccY    equ 1
def szEntity_VelY    equ 1
def szEntity_PosY    equ 2
def szEntity_Collide equ 2
def szEntity_DispX   equ 1
def szEntity_DispY   equ 1

rsreset
def Entity_Info    rb szEntity_Info
def Entity_Ctrl    rb szEntity_Ctrl
def Entity_AccX    rb szEntity_AccX
def Entity_VelX    rb szEntity_VelX
def Entity_PosX    rb szEntity_PosX
def Entity_AccY    rb szEntity_AccY
def Entity_VelY    rb szEntity_VelY
def Entity_PosY    rb szEntity_PosY
def Entity_Collide rb szEntity_Collide
def Entity_DispX rb szEntity_DispX
def Entity_DispY rb szEntity_DispY
def _Entity_Pad    rb 2
def szEntity    rb 0


def ENTINFOB_ID0 equ 0
def ENTINFOB_ID1 equ 1
def ENTINFOB_ID2 equ 2
def ENTINFOB_ID3 equ 3
def _ENTINFOB_4 equ 4
def ENTINFOB_INVIEW equ 5
def ENTINFOB_ALIVE equ 6
def ENTINFOB_OCCUPIED equ 7

def ENTINFOF_ID equ $0F
def _ENTINFOF_4 equ 1 << _ENTINFOB_4
def ENTINFOF_INVIEW equ 1 << ENTINFOB_INVIEW
def ENTINFOF_ALIVE equ 1 << ENTINFOB_ALIVE
def ENTINFOF_OCCUPIED equ 1 << ENTINFOB_OCCUPIED


rsreset
;; Drag model/curve selection
def bENTCTRL_DRAG rb 2
;; Disable gravity
def bENTCTRL_NOGRAV equ 4

def ENTCTRL_DRAG_A equ 0
def ENTCTRL_DRAG_NONE equ 1
def ENTCTRL_DRAG equ $03
def ENTCTRL_NOGRAV equ 1 << bENTCTRL_NOGRAV


macro entity_index
	assert _NARG == 1
	assert (\1) <= szEntity
	ld a, l
	and $F0
	add (\1)
	ld l, a
endm


rsreset
;; Target function bank
def EntityFn_Bank rb 1
;; Pad to power of two (4) for alignment
def EntityFn_Padding rb 1
;; Target function address
def EntityFn_Target rb 2
;; Size of an EntityFn struct
def szEntityFn rb 0

assert szEntityFn == 1 << (bitwidth(szEntityFn - 1)), "Expected power of two szEntityFn."


;; Size of per-Entity implementor use block
def szEntityUsr0 equ 16


endc ; Q_ENTITY_INC_b4moRE1M
