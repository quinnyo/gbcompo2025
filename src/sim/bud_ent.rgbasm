include "hardware.inc"
include "sim/entity.rgbinc"
include "coord.rgbinc"
include "banker.rgbinc"
include "chrimp.rgbinc"
include "sprite.rgbinc"
include "ani.rgbinc"


;; Action period duration range mask.
def PERIOD_MASK equ $00
;; Action period duration minimum value (offset).
def PERIOD_MIN equ $0F

;; Drive vector scale as number of bits to shift right
def DRIVE_RSHIFTS equ 3

;; Target point offset range bitmask
def TARGET_OFFSET_MASK equ 31
assert TARGET_OFFSET_MASK & (TARGET_OFFSET_MASK + 1) == 0

rsreset
def bBudEnt__0 rb 1
def bBudEnt__1 rb 1
def bBudEnt__2 rb 1
def bBudEnt__3 rb 1
def bBudEnt_XTURNING rb 1
;; Facing left
def bBudEnt_LEFT rb 1
def bBudEnt__6 rb 1
;; Set if anchor is 'home' item.
def bBudEnt_HOME rb 1

assert bBudEnt_LEFT == OAMB_XFLIP

def BudEnt_XTURNING equ 1 << bBudEnt_XTURNING
def BudEnt_LEFT equ 1 << bBudEnt_LEFT
def BudEnt_HOME equ 1 << bBudEnt_HOME
def BudEnt_STATUS_DEFAULT equ BudEnt_HOME


rsreset
def BudEnt_status rb 1
def BudEnt_timer rb 1
;; Anchor object ID -- home item or leader entity (if picked up).
def BudEnt_anchor rb 1
def BudEnt_driveX rb 1
def BudEnt_driveY rb 1
;; Find/Item typeid
def BudEnt_typeid rb 1
def BudEnt_ani rb szAni

def szBudEnt rb 0
assert szBudEnt <= szEntityUsr0, "Bud struct exceeds Entity Usr0 allocation. ({d:szBudEnt} > {d:szEntityUsr0})"


import_chr "assets/ent/afish.chr", Afish, pal


section "Afish_ani", romx

Afish_aniDefault:
	.f0:
		ani_frame 13, .f1
		sprob 8, 0, 0, 0
		sprob_end
	.f1:
		ani_frame 17, .f0
		sprob 8, 0, 1, 0
		sprob_end

Afish_aniTurn:
	.f0:
		ani_frame 9, .f1
		sprob 8 - 1, 2, 2, OAMF_XFLIP
		sprob_end
	.f1:
		ani_frame 5, Afish_aniDefault.f0
		sprob 8, 0, 2, 0
		sprob_end


section "wBudEntRes", wram0
wAfishPal0: db
wAfishChri: db


section "BudEntResourceInit", rom0
BudEntResourceInit::
	ld b, bank(Afish_pal)
	ld de, Afish_pal
	call PalettePalLoadObRomx
	ld a, b :: and $07 :: ld [wAfishPal0], a

	ld c, Afish_CHR_COUNT
	call ChrmanAllocOb
	ld a, b :: ld [wAfishChri], a
	jr c, .err_alloc_ob
	ld c, Afish_CHR_COUNT - 1
	ld b, bank(Afish_chr)
	ld de, Afish_chr
	call VxLoadRom

	ret
.err_alloc_ob
	ld b, b
	ret


section "BudEntSpawn", rom0
;; NOTE: Assumes entity to possess is selected/active (hEntityActive)
;; @param B: home Item index
;; @param C: Find typeid
;; @param SP+0: PosX
;; @param SP+2: PosY
;; @mut: AF, BC, DE, HL
BudEntSpawn::
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a
	ld a, ENTINFOF_OCCUPIED | ENTINFOF_ALIVE | $02
	ld [hl+], a ; info
	ld a, ENTCTRL_DRAG_A
	ld [hl+], a ; ctrl
	xor a
	ld [hl+], a ; accx
	ld a, -63
	ld [hl+], a ; velx
		pop de ; x
	ld a, e :: ld [hl+], a ; posx.lo
	ld a, d :: ld [hl+], a ; posx.hi
	xor a
	ld [hl+], a ; accy
	ld a, -47
	ld [hl+], a ; vely
		pop de ; y
	ld a, e :: ld [hl+], a ; posy.lo
	ld a, d :: ld [hl+], a ; posy.hi

		wrambpush bank(wEntityUsr0)
	ldh a, [hEntityActive.usr0 + 0] :: ld l, a
	ldh a, [hEntityActive.usr0 + 1] :: ld h, a
	ld a, BudEnt_STATUS_DEFAULT :: ld [hl+], a ; .status
	ld a, 1 :: ld [hl+], a ; .timer
	ld a, b :: ld [hl+], a ; .anchor
	xor a
	ld [hl+], a ; .driveX
	ld [hl+], a ; .driveY
	ld a, c :: ld [hl+], a ; .typeid
		push hl
	call AniInit
		pop hl
	ld de, Afish_aniDefault.f0
	ld b, bank("Afish_ani")
	call AniSetFrame
		wrambpop

	ld de, EntityFnUpdateMotionOnly
	ld b, bank(EntityFnUpdateMotionOnly)
	ldh a, [hEntityActive.index]
	call EntitySetFnUpdate

	ld de, BudEntFnThink
	ld b, bank(BudEntFnThink)
	ldh a, [hEntityActive.index]
	call EntitySetFnThink

	ld de, BudEntFnRender
	ld b, bank(BudEntFnRender)
	ldh a, [hEntityActive.index]
	call EntitySetFnRender

	ret


pushs "aaaQuickMon", wram0

aaa_BudStatus: db
aaa_BudTimer: db

pops ; aaaQuickMon


pushs "_Bud", wram0
_BudAnchorX: dw
_BudTargetX: dw
_BudDriveX: db
_BudAnchorY: dw
_BudTargetY: dw
_BudDriveY: db
pops ; _Bud


section "BudEntFnThink", romx
BudEntFnThink::
		wrambsel bank(wEntityUsr0)
	ldh a, [hEntityActive.usr0 + 0] :: ld l, a
	ldh a, [hEntityActive.usr0 + 1] :: ld h, a

															ld a, [hl+] :: ld [aaa_BudStatus], a
															ld a, [hl-] :: ld [aaa_BudTimer], a

	; If at home, monitor home item collection status.
	; Switch to following player entity if home item is picked up.
	bit bBudEnt_HOME, [hl]
	jr z, :+
		push hl
	ld a, BudEnt_typeid
	add l :: ld l, a
	ld a, [hl] ; .typeid
	call FindsQuery
		pop hl
	jr z, :+
	; clear HOME flag & change anchor to player entity
	res bBudEnt_HOME, [hl]
	ld e, l ; keep pointer to .status
	rept BudEnt_anchor - BudEnt_status
		inc l
	endr
	ld a, [wPlayer.ent] :: ld [hl], a ; .anchor
	ld l, e ; back to .status
:

.tick:
	ld a, [hl+] :: ld b, a ; .status
	dec [hl]
	jr z, .period_start
	ld a, [hl+]

.action:
	inc hl ; skip .anchor
	; set accel from drive vector
.apply_drive_accel
	ld a, [hl+] :: ld c, a ; driveX
	ld a, [hl+] :: ld b, a ; driveY
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a
	entity_index Entity_AccX
	ld [hl], c
	entity_index Entity_AccY
	ld [hl], b
	ret

	; start a new period
.period_start:
	; get up to date anchor/target point and pick a new drive vector (towards the target)
									inc hl ; skip .timer
	ld a, [hl+] ; .anchor
	call _GetTargetPoint
	ret nc ; _GetTargetPoint failed

															ld a, e :: ld [_BudTargetX + 0], a
															ld a, d :: ld [_BudTargetX + 1], a
															ld a, c :: ld [_BudTargetY + 0], a
															ld a, b :: ld [_BudTargetY + 1], a

	; DriveY
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a
	entity_index Entity_PosY
	ld a, [hl+]
	ld h, [hl]
	ld l, a
	coord_int16 hl ; working in Dots
	coord_sub bc, hl
	rl b :: sbc a ; to shift sign into the low byte
	rept DRIVE_RSHIFTS
		rra :: rr c
	endr
															ld a, c :: ld [_BudDriveY], a

	; DriveX
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a
	entity_index Entity_PosX
	ld a, [hl+]
	ld h, [hl]
	ld l, a
	coord_int16 hl ; working in Dots
	coord_sub de, hl
	rl d :: sbc a ; to shift sign into the low byte
	rept DRIVE_RSHIFTS
		rra :: rr e
	endr
															ld a, e :: ld [_BudDriveX], a
	
	; next timer duration
	call CnsNext :: and PERIOD_MASK :: add PERIOD_MIN
	ld b, a ; hang on to this for a moment

	; store drive vec
	ldh a, [hEntityActive.usr0 + 0] :: ld l, a
	ldh a, [hEntityActive.usr0 + 1] :: ld h, a

	; update left/right facing flag
	; D is already signed from DriveX
	ld a, [hl]
	xor d
	and ~BudEnt_LEFT
	xor d
	; if changed do turning animation
	cp [hl]
	jr z, :+
	or BudEnt_XTURNING
:
	ld [hl+], a ; .status
	ld a, b :: ld [hl+], a ; .timer
	inc hl ; skip .anchor
	; store the new drive vector
	ld a, e :: ld [hl+], a ; driveX
	ld [hl], c ; driveY
	ret


;; @param A: BudEnt.anchor
;; @param B: BudEnt.status
;; @ret F.C: success
;; @ret DE: TargetX (dots)
;; @ret BC: TargetY (dots)
;; @mut: AF, BC, DE, HL
_GetTargetPoint:
	; Anchor
	bit bBudEnt_HOME, b
	jr z, .leader_entity
	; anchor is home item
	call ItemsGetPosition
	jr .do_target_offset

.leader_entity
	; anchor is leader entity
	call EntityAt
	ret nc
	entity_index Entity_PosX
	ld a, [hl+] :: ld e, a
	ld d, [hl]
	coord_int16 de
	entity_index Entity_PosY
	ld a, [hl+] :: ld c, a
	ld b, [hl]
	coord_int16 bc

.do_target_offset
	; Target = Anchor + random offset

															ld a, e :: ld [_BudAnchorX + 0], a
															ld a, d :: ld [_BudAnchorX + 1], a
															ld a, c :: ld [_BudAnchorY + 0], a
															ld a, b :: ld [_BudAnchorY + 1], a

	; TargetY random offset
	call CnsNext :: and TARGET_OFFSET_MASK :: ld l, a
	ld h, 0 ; H will collect our borrow
	ld a, c :: sub TARGET_OFFSET_MASK >> 1
	rl h ; H[0] <~~~ F.C
	add l :: ld c, a
	adc b :: sub c
	sub h :: ld b, a
	jr nc, :+
	; underflow: clamp to low bound
	ld bc, WORLD_ORIGIN >> 4
:
	; TargetX random offset
	call CnsNext :: and TARGET_OFFSET_MASK :: ld l, a
	ld h, 0
	ld a, e :: sub TARGET_OFFSET_MASK >> 1
	rl h
	add l :: ld e, a
	adc d :: sub e
	sub h :: ld d, a
	jr nc, :+
	ld de, WORLD_ORIGIN >> 4
:
	scf
	ret


section "BudEntFnRender", romx
BudEntFnRender::
	ld a, [wAfishChri] :: ld d, a
	ld a, [wAfishPal0] :: ld e, a

		wrambsel bank(wEntityUsr0)
	ldh a, [hEntityActive.usr0 + 0] :: ld l, a
	ldh a, [hEntityActive.usr0 + 1] :: ld h, a
	ld b, [hl] ; status
	res bBudEnt_XTURNING, [hl]

	; (update render atrbs)
	ld a, b :: and OAMF_XFLIP
	or e :: ld e, a

		push de
	ld de, BudEnt_ani
	add hl, de

	; trigger turn animation if reversed X direction this frame
	bit bBudEnt_XTURNING, b
	jr z, :+
	; turn anim
		push hl
	ld de, Afish_aniTurn.f0
	ld b, bank("Afish_ani")
	call AniSetFrame
		pop hl
:
	ld d, 1 ; delta time
	call AniUpdate
		pop de

	; HL: Ani drawable pointer, abort if $FFFF
	ld a, l :: and h
	inc a
	jp nz, _BudEntSprxRender
	ret


section "_BudEntSprxRender", rom0
;; End of BudEnt render function, in ROM0 for safe banking.
_BudEntSprxRender:
		rombsel b
	; position
		push hl
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a
	entity_index Entity_DispX
	ld a, [hl+] :: add 8 :: ld c, a
	ld a, [hl+] :: add 4 :: ld b, a
		pop hl

	jp SprxRenderMod

