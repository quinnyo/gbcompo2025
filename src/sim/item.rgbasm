include "hardware.inc"
include "coord.rgbinc"
include "chrimp.rgbinc"
include "sprite.rgbinc"
include "banker.rgbinc"
include "quest/quest.rgbinc"
include "map.rgbinc"
include "item.rgbinc"

/*
Items are pickupable (pickable up) *things*.
*/


import_chr "assets/ent/markers.chr", Markers, pal


section "ItemSprites", romx
ItemSprites:
	dw sprItemBud
	dw sprItem0
	dw sprItem1
	dw sprItem2
	dw sprItem3
	dw sprItem4

def ITEM_SPRITES_MAX equ (@ - ItemSprites) / 2

sprItem0:
	sprob 12, 4, 0, 0
	sprob_end

sprItem1:
	sprob 12, 4, 1, 0
	sprob_end

sprItem2:
	sprob 12, 4, 2, 0
	sprob_end

sprItem3:
	sprob 12, 4, 3, 0
	sprob_end

sprItem4:
	sprob 12, 4, 4, 0
	sprob_end

sprItemBud:
	sprob 12, 4, $0B, 0
	sprob_end

sprItemMissing:
	sprob 12, 4, $0F, 0
	sprob_end


section "wItems", wramx
wItems: ds ITEMS_MAX * szItem


section "wItemsManager", wram0
wItemsManager:
	.flags: db
	.collideY: db
	.collideX: db


section "wItemsResources", wram0
wItemsRes_markers_chri: db
wItemsRes_markers_pal: db


section "ItemsInit", rom0
ItemsInit::
	ld b, bank(Markers_pal)
	ld de, Markers_pal
	call PalettePalLoadObRomx
	ld a, b :: and $07 :: ld [wItemsRes_markers_pal], a

	; TODO: only load item graphics that are being used

	ld c, Markers_CHR_COUNT
	call ChrmanAllocOb
	ret c
	ld a, b :: ld [wItemsRes_markers_chri], a
	ld b, bank(Markers_chr)
	ld de, Markers_chr
	ld c, Markers_CHR_COUNT - 1
	call VxLoadRom

	jp ItemsReset


section "ItemsReset", rom0
ItemsReset::
		wrambpush bank("wItems")
	ld hl, startof("wItems")
	ld c, sizeof("wItems")
	xor a
	call MemFillSmall
		wrambpop
	ld hl, startof("wItemsManager")
	ld c, sizeof("wItemsManager")
	xor a
	jp MemFillSmall


section "ItemsGetEmptySlot", rom0
;; Search wItems for an unused slot (where ItemCtl_ENABLE is not set).
;; @ret HL: pointer to empty item slot (if found)
;; @ret C: index of item slot (if found)
;; @ret F.C: set on success (empty slot found)
;; @mut: AF, C, HL
ItemsGetEmptySlot::
		wrambopen bank("wItems")
;; Alternative `ItemsGetEmptySlot` entry point that skips default banking.
;; Calling context is to ensure WRAMX bank containing "wItems" is active.
.skip_banking:
	ld hl, wItems
	ld c, ITEMS_MAX
:
	bit bItemCtl_ENABLE, [hl]
	jr z, .success
	ld a, szItem
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	dec c
	jr nz, :-
	xor a ; F.NC
	ret
.success:
	ld a, ITEMS_MAX :: sub c :: ld c, a
	scf ; F.C
	ret


;; Search wItems for an unused slot (where ItemCtl_ENABLE is not set).
;; Same as `ItemsGetEmptySlot` except the WRAM bank containing the Item will be selected.
;; NOTE: The active WRAM bank will not be preserved by this function.
;; @ret HL: pointer to empty item slot (if found)
;; @ret C: index of item slot (if found)
;; @ret F.C: set on success (empty slot found)
;; @mut: AF, C, HL
ItemsGetEmptySlotAndBank::
		wrambsel bank("wItems")
	jr ItemsGetEmptySlot.skip_banking


section "ItemsIndex", rom0
;; @param A: index
;; @ret HL: items[index]
;; @ret F.C: set if index in range
ItemsIndex::
	cp ITEMS_MAX
	ret nc

	ld l, a
	ld h, 0
	assert szItem == 1 << (bitwidth(szItem) - 1)
	rept bitwidth(szItem) - 1
		add hl, hl
	endr
		push bc
	ld bc, wItems
	add hl, bc
		pop bc

	scf
	ret


section "ItemsGetPosition", rom0
;; Get item position in dots
;; @param A: index
;; @ret DE: X position in dots
;; @ret BC: Y position in dots
;; @ret F.C: success
;; @mut: AF, BC, DE, HL
ItemsGetPosition::
	call ItemsIndex
	ret nc
		wrambopen bank("wItems")
	ld a, Item_y
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld b, a
	ld a, [hl+] :: ld e, a
	ld a, [hl+] :: ld d, a
	scf
	ret


section "ItemsGetPositionCoord", rom0
;; Get item position as Entity coords
;; @param A: index
;; @ret DE: X position in Entity coords
;; @ret BC: Y position in Entity coords
;; @ret F.C: success
;; @mut: AF, BC, DE, HL
ItemsGetPositionCoord::
	call ItemsIndex
	ret nc
		wrambopen bank("wItems")
	ld a, Item_y
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld b, a
	coord_from_dots16 bc
	ld a, [hl+] :: ld e, a
	ld a, [hl+] :: ld d, a
	coord_from_dots16 de
	scf
	ret


section "ItemsSetCollidePoint", rom0
;; Enable Item collision detection and set query point, or disable collision detection.
;; @param A: non-zero to enable collision, zero to disable
;; @param D,E: collision point Y,X position (screen dots)
ItemsSetCollidePoint::
	and a
	jr z, .disable
	ld hl, wItemsManager.collideX
	ld a, e :: ld [hl-], a
	ld a, d :: ld [hl-], a
	set bItems_COLLIDE_ENABLE, [hl]
	ret
.disable
	ld hl, wItemsManager.flags
	res bItems_COLLIDE_ENABLE, [hl]
	ret


section "ItemsUpdate", rom0
ItemsUpdate::
	rombopen bank(ItemSprites)
	wrambopen bank("wItems")
	ld hl, wItems
	ld c, ITEMS_MAX
.loop
	bit bItemCtl_ENABLE, [hl]
	jr z, :+
		push hl :: push bc
	call _update_item
		pop bc :: pop hl
:
	ld a, szItem
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	dec c
	jr nz, .loop
	ret


_update_item:
	res bItemCtl_TOUCHED, [hl]
		push hl
	inc hl :: inc hl :: inc hl ; skip .ctl, .typeid
	call _get_screen_position ; B,C: Y,X
		pop hl
	ret nc

	; collide
	ld a, [wItemsManager.flags]
	and Items_COLLIDE_ENABLE
	jr z, .draw_item

	ld a, [wItemsManager.collideY]
	sub b
	call AbsS8
	cp ITEM_TOUCH_RANGE
	jr nc, .draw_item

	ld a, [wItemsManager.collideX]
	sub c
	call AbsS8
	cp ITEM_TOUCH_RANGE
	jr nc, .draw_item

	set bItemCtl_TOUCHED, [hl]

	; collect item
		push hl
	inc hl ; skip .ctl
	ld a, [hl] ; id
	call FindsAdd
		pop hl

.draw_item
	; Default CHR index & palette offset
	ld a, [wItemsRes_markers_chri] :: ld d, a
	ld a, [wItemsRes_markers_pal] :: ld e, a

	ld a, [hl+] ; ctl
	bit bItemCtl_TOUCHED, a
	jr z, :+
	; DEBUG: swap palette to show TOUCHED state
	dec e
:

		push de :: push hl
	ld a, [hl] ; id
	call FindsQuery
		pop hl :: pop de
	jr nz, :+
	; DEBUG: show 'not collected' with cycling palette
	ld a, [wVBlankCount]
	rrca :: rrca
	add e
	and $07
	ld e, a
:

	ld a, [hl] ; id
	cp ITEM_SPRITES_MAX
	jr c, :+
	ld hl, sprItemMissing
	jp SprxRenderMod
:
	add a ; mul 2
	ld hl, ItemSprites
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	ld a, [hl+]
	ld h, [hl]
	ld l, a
	jp SprxRenderMod


;; @param HL: pointer to item Y position
;; @ret B,C: Y,X
;; @ret F.C: set if (potentially) visible
;; @mut: AF, BC, DE, HL
_get_screen_position:
	ld a, [wScroll.y + 0] :: ld e, a
	ld a, [wScroll.y + 1] :: ld d, a
	; load item position and subtract scroll position
	ld a, [hl+] :: sub e :: ld c, a
	ld a, [hl+] :: sbc d :: ld b, a

		push bc
	ld a, [wScroll.x + 0] :: ld c, a
	ld a, [wScroll.x + 1] :: ld b, a
	ld a, [hl+] :: sub c :: ld e, a
	ld a, [hl+] :: sbc b :: ld d, a
		pop bc

	jp SprxTestVisibility

