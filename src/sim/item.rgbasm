include "hardware.inc"
include "coord.rgbinc"
include "chrimp.rgbinc"
include "sprite.rgbinc"
include "banker.rgbinc"
include "quest/quest.rgbinc"
include "map.rgbinc"

/*
Items are pickupable (pickable up) *things*.
*/


;; Maximum number of item instances
def ITEMS_MAX equ 8
;; Item touch (pickup) collision radius
def ITEM_TOUCH_RANGE equ 7

/*
Items global/manager control flags
*/
rsreset
def bItems_COLLIDE_ENABLE rb 1
def Items_COLLIDE_ENABLE equ 1 << bItems_COLLIDE_ENABLE

/*
Item instance status & control flags
*/
rsreset
;; Item exists & should be processed. Marks slot as occupied.
def bItemCtl_ENABLE rb 1
;; Is visible / is inside view rect
def bItemCtl_VISIBLE rb 1
;; Being touched
def bItemCtl_TOUCHED rb 1

def ItemCtl_NULL equ 0
def ItemCtl_ENABLE  equ 1 << bItemCtl_ENABLE
def ItemCtl_VISIBLE equ 1 << bItemCtl_VISIBLE
def ItemCtl_TOUCHED equ 1 << bItemCtl_TOUCHED

/*
Item (in-world item instance)
*/
rsreset
;; Status & control flags
def Item_ctl rb 1
;; Find/Item typeid
def Item_typeid rb 2
;; Y position of the item in dots.
def Item_y rb 2
;; X position of the item in dots.
def Item_x rb 2
def Item_padding rb 1
def szItem rb 0
assert szItem == szItem & -szItem, "Expected power-of-two szItem"


import_chr "assets/ent/markers.chr", Markers, pal


section "ItemSprites", romx
ItemSprites:
	dw sprItemBud
	dw sprItem0
	dw sprItem1
	dw sprItem2
	dw sprItem3
	dw sprItem4

def ITEM_SPRITES_MAX equ (@ - ItemSprites) / 2

sprItem0:
	sprob 12, 4, 0, 0
	sprob_end

sprItem1:
	sprob 12, 4, 1, 0
	sprob_end

sprItem2:
	sprob 12, 4, 2, 0
	sprob_end

sprItem3:
	sprob 12, 4, 3, 0
	sprob_end

sprItem4:
	sprob 12, 4, 4, 0
	sprob_end

sprItemBud:
	sprob 12, 4, $0B, 0
	sprob_end

sprItemMissing:
	sprob 12, 4, $0F, 0
	sprob_end


section "wItems", wramx
wItems: ds ITEMS_MAX * szItem


section "wItemsManager", wram0
wItemsManager:
	.flags: db
	.collideY: db
	.collideX: db


section "wItemsResources", wram0
wItemsRes_markers_chri: db
wItemsRes_markers_pal: db


section "ItemsInit", rom0
ItemsInit::
	ld b, bank(Markers_pal)
	ld de, Markers_pal
	call PalettePalLoadObRomx
	ld a, b :: and $07 :: ld [wItemsRes_markers_pal], a

	; TODO: only load item graphics that are being used

	ld c, Markers_CHR_COUNT
	call ChrmanAllocOb
	ret c
	ld a, b :: ld [wItemsRes_markers_chri], a
	ld b, bank(Markers_chr)
	ld de, Markers_chr
	ld c, Markers_CHR_COUNT - 1
	call VxLoadRom

	jp ItemsReset


section "ItemsReset", rom0
ItemsReset::
		wrambpush bank("wItems")
	ld hl, startof("wItems")
	ld c, sizeof("wItems")
	xor a
	call MemFillSmall
		wrambpop
	ld hl, startof("wItemsManager")
	ld c, sizeof("wItemsManager")
	xor a
	jp MemFillSmall


section "ItemsGetEmptySlot", rom0
;; @ret HL: pointer to empty item slot (if found)
;; @ret F.Z: set on success (empty slot found)
;; @mut: AF, C, HL
ItemsGetEmptySlot::
		wrambopen bank("wItems")
.skip_banking:
	ld hl, wItems
	ld c, ITEMS_MAX
:
	bit bItemCtl_ENABLE, [hl]
	ret z
	ld a, szItem
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	dec c
	jr nz, :-
	inc a ; clear F.Z
	ret


section "ItemsSpawnMapObject", rom0
;; @param DE: pointer to source MapObject
;; @mut: AF, C, DE, HL
ItemsSpawnMapObject::
		wrambopen bank("wItems")
	call ItemsGetEmptySlot.skip_banking
	jr nz, .failed

	; Main part of Item & MapObject are the same, so just copy it.
	ld a, ItemCtl_ENABLE :: ld [hl+], a ; ctl
	ld c, szMapObject
	jp MemCopySmall
.failed:
	ld b, b
	ret


section "ItemsIndex", rom0
;; @param A: index
;; @ret HL: items[index]
;; @ret F.C: set if index in range
ItemsIndex::
	cp ITEMS_MAX
	ret nc

	ld l, a
	ld h, 0
	assert szItem == 1 << (bitwidth(szItem) - 1)
	rept bitwidth(szItem) - 1
		add hl, hl
	endr
		push bc
	ld bc, wItems
	add hl, bc
		pop bc

	scf
	ret


section "ItemsSetupSpecial", rom0
;; @mut: AF, C, DE, HL
ItemsSetupSpecial::
		wrambopen bank("wItems")
	ld b, 0
:
		push bc
	ld a, b
	call ItemsIndex
	ld a, [hl+]
	and ItemCtl_ENABLE
	jr z, .next

	; Check if item is a Bud spawnpoint/home.
	ld a, [hl+] :: ld c, a ; .typeid.lo
	inc hl ; skip .typeid.hi
	ld e, c
	call TypGetClass
	; check Typ lookup success
	jr nc, .next
	ld a, d
	cp typclBud
	call z, .spawn_bud ; spawn Bud entity if class is Bud

.next
		pop bc
	inc b
	ld a, b
	cp ITEMS_MAX
	jr c, :-
	ret

.spawn_bud
		push bc :: push hl ; preserve item typeid (C), index (B), pointer (HL)
	call EntityActiveSelectEmpty
		pop hl :: pop bc
	ret nc

	ld a, [hl+] :: ld e, a
	ld a, [hl+] :: ld d, a
	coord_from_dots16 de
		push de ; y
	ld a, [hl+] :: ld e, a
	ld a, [hl+] :: ld d, a
	coord_from_dots16 de
		push de ; x
	jp BudEntSpawn


section "ItemsGetPosition", rom0
;; Get item position in dots
;; @param A: index
;; @ret DE: X position in dots
;; @ret BC: Y position in dots
;; @ret F.C: success
;; @mut: AF, BC, DE, HL
ItemsGetPosition::
	call ItemsIndex
	ret nc
		wrambopen bank("wItems")
	ld a, Item_y
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld b, a
	ld a, [hl+] :: ld e, a
	ld a, [hl+] :: ld d, a
	scf
	ret


section "ItemsGetPositionCoord", rom0
;; Get item position as Entity coords
;; @param A: index
;; @ret DE: X position in Entity coords
;; @ret BC: Y position in Entity coords
;; @ret F.C: success
;; @mut: AF, BC, DE, HL
ItemsGetPositionCoord::
	call ItemsIndex
	ret nc
		wrambopen bank("wItems")
	ld a, Item_y
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld b, a
	coord_from_dots16 bc
	ld a, [hl+] :: ld e, a
	ld a, [hl+] :: ld d, a
	coord_from_dots16 de
	scf
	ret


section "ItemsSetCollidePoint", rom0
;; Enable Item collision detection and set query point, or disable collision detection.
;; @param A: non-zero to enable collision, zero to disable
;; @param D,E: collision point Y,X position (screen dots)
ItemsSetCollidePoint::
	and a
	jr z, .disable
	ld hl, wItemsManager.collideX
	ld a, e :: ld [hl-], a
	ld a, d :: ld [hl-], a
	set bItems_COLLIDE_ENABLE, [hl]
	ret
.disable
	ld hl, wItemsManager.flags
	res bItems_COLLIDE_ENABLE, [hl]
	ret


section "ItemsUpdate", rom0
ItemsUpdate::
	rombopen bank(ItemSprites)
	wrambopen bank("wItems")
	ld hl, wItems
	ld c, ITEMS_MAX
.loop
	bit bItemCtl_ENABLE, [hl]
	jr z, :+
		push hl :: push bc
	call _update_item
		pop bc :: pop hl
:
	ld a, szItem
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	dec c
	jr nz, .loop
	ret


_update_item:
	res bItemCtl_TOUCHED, [hl]
		push hl
	inc hl :: inc hl :: inc hl ; skip .ctl, .typeid
	call _get_screen_position ; B,C: Y,X
		pop hl
	ret nc

	; collide
	ld a, [wItemsManager.flags]
	and Items_COLLIDE_ENABLE
	jr z, .draw_item

	ld a, [wItemsManager.collideY]
	sub b
	call AbsS8
	cp ITEM_TOUCH_RANGE
	jr nc, .draw_item

	ld a, [wItemsManager.collideX]
	sub c
	call AbsS8
	cp ITEM_TOUCH_RANGE
	jr nc, .draw_item

	set bItemCtl_TOUCHED, [hl]

	; collect item
		push hl
	inc hl ; skip .ctl
	ld a, [hl] ; id
	call FindsAdd
		pop hl

.draw_item
	; Default CHR index & palette offset
	ld a, [wItemsRes_markers_chri] :: ld d, a
	ld a, [wItemsRes_markers_pal] :: ld e, a

	ld a, [hl+] ; ctl
	bit bItemCtl_TOUCHED, a
	jr z, :+
	; DEBUG: swap palette to show TOUCHED state
	dec e
:

		push de :: push hl
	ld a, [hl] ; id
	call FindsQuery
		pop hl :: pop de
	jr nz, :+
	; DEBUG: show 'not collected' with cycling palette
	ld a, [wVBlankCount]
	rrca :: rrca
	add e
	and $07
	ld e, a
:

	ld a, [hl] ; id
	cp ITEM_SPRITES_MAX
	jr c, :+
	ld hl, sprItemMissing
	jp SprxRenderMod
:
	add a ; mul 2
	ld hl, ItemSprites
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	ld a, [hl+]
	ld h, [hl]
	ld l, a
	jp SprxRenderMod


;; @param HL: pointer to item Y position
;; @ret B,C: Y,X
;; @ret F.Z: set if successful (both axes in 0..256)
;; @mut: AF, BC, DE, HL
_get_screen_position:
	ld a, [wScroll.y + 0] :: ld e, a
	ld a, [wScroll.y + 1] :: ld d, a
	; load item position and subtract scroll position
	ld a, [hl+] :: sub e :: ld c, a
	ld a, [hl+] :: sbc d :: ld b, a

		push bc
	ld a, [wScroll.x + 0] :: ld c, a
	ld a, [wScroll.x + 1] :: ld b, a
	ld a, [hl+] :: sub c :: ld e, a
	ld a, [hl+] :: sbc b :: ld d, a
		pop bc

	jp SprxTestVisibility

