include "hardware.inc"
include "sim/entity.rgbinc"
include "coord.rgbinc"
include "vis/diver.rgbinc"


def bVKEY_FLAP        equ 0
def bVKEY_AUTOFLAP    equ 1

def FLAP_FULL equ $0D
def FLAP_AUTO equ $0C
def AUTOFLAP_THRESHOLD equ $02

def THRUST_TICK equ $07


section "wPlayer", wram0
wPlayer::
	.vkeys: db
	.ent: dw
	.vis:: ds szVisDiver


section "hPlayer", hram
;; Direct directional movement vector, Y axis
hPlayerDriveY: db
;; 'Drive' movement control vector, X axis
hPlayerDriveX: db


section "Player", rom0
PlayerInit::
	xor a
	ld [wPlayer.vkeys], a
	ldh [hPlayerDriveY], a
	ldh [hPlayerDriveX], a
	ld a, $FF
	ld [wPlayer.ent+0], a
	ld [wPlayer.ent+1], a

	ld hl, wPlayer.vis
	jp VisDiverReset


;; @param HL: player entity
;; @mut: AF, HL
PlayerSpawn::
	ld a, l :: ld [wPlayer.ent+0], a
	ld a, h :: ld [wPlayer.ent+1], a

	ld a, ENTINFOF_ALIVE | $01
	ld [hl+], a
	xor a :: ld [hl+], a
	; accx
	ld a, 40 :: ld [hl+], a
	; velx
	ld a, 40 :: ld [hl+], a
	; posx
	coord_ld_hli_int 8 * 6 ;(WORLD_ORIGIN >> 4) + 90
	; accy
	ld a, -20 :: ld [hl+], a
	; vely
	ld a, 20 :: ld [hl+], a
	; posy
	coord_ld_hli_int 8 * 4 ;(WORLD_ORIGIN >> 4) + 50

	ret


;; Player entity controller: per-tick update function
;; @mut: AF, BC, D, HL
PlayerUpdate::
	call PlayerInputUpdate

	call PlayerGetEntity
	ret z

	entity_index Entity_Ctrl
	; set NOGRAV if active directional input.
	res bENTCTRL_NOGRAV, [hl]
	ld a, e :: or d
	jr z, :+
	set bENTCTRL_NOGRAV, [hl]
:

	; Directional movement
	ldh a, [hSim.tick]
	and THRUST_TICK
	ret nz

	entity_index Entity_AccY
	ld [hl], d
	entity_index Entity_AccX
	ld [hl], e

	ret


;; @ret HL: pointer to player entity (if F.NZ)
;; @ret F.Z: null entity
PlayerGetEntity::
	ld hl, wPlayer.ent
	ld a, [hl+]
	ld h, [hl]
	ld l, a
	; if .ent == $FFFF, abort
	and h :: inc a
	ret


PlayerRender::
	call PlayerGetEntity
	ret z

	; After scrolling, adjust display position
	entity_index Entity_DispX
	ld a, [hl+] :: ld c, a
	ldh a, [hScrollAppliedX]
	cpl :: inc a :: add c :: add ENT_SPRITE_X_OFF :: ld c, a
	assert Entity_DispY == Entity_DispX + 1
	ld a, [hl+] :: ld b, a
	ldh a, [hScrollAppliedY]
	cpl :: inc a :: add b :: add ENT_SPRITE_Y_OFF :: ld b, a

		push bc

	; Update vis ctl speed
	ld b, 0
	ldh a, [hPlayerDriveY]
	ld c, a
	ldh a, [hPlayerDriveX]
	or c
	jr z, .nodrive
	entity_index Entity_VelY
	ld a, [hl]
	call _abs
	ld b, a
	entity_index Entity_VelX
	ld a, [hl]
	call _abs
	or b
	srl a
	cp VisDiverCtl_SPEED+1
	jr c, :+
	ld a, VisDiverCtl_SPEED
:
	ld b, a
.nodrive
	; ctl.HEADING
	ldh a, [hKeys]
	and VisDiverCtl_HEADING
	or b
	ld hl, wPlayer.vis
	call VisDiverSetCtl

		pop bc

	; update position
	ld hl, wPlayer.vis
	ld a, b :: ld [hl+], a
	ld a, c :: ld [hl-], a
	call VisDiverUpdate

	ret


_abs:
	cp $80
	ret c
	jr nz, :+
	dec a
	ret
:
	cpl :: inc a
	ret


PlayerViewTarget::
	call PlayerGetEntity
	ret z

	; player entity Y position
	entity_index Entity_PosY
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld b, a
	coord_int16 bc

	; view rect centre
	ld a, [wScroll.y + 0]
	add 144 / 2 :: ld e, a
	ld a, [wScroll.y + 1]
	adc e :: sub e :: ld d, a

	coord_sub bc, de
	entity_index Entity_DispY
	ld a, c :: add 144 / 2 :: ld [hl], a
	call _ScrollFenceThing
	ld [wScroll.dy], a

	; player entity X position
	entity_index Entity_PosX
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld b, a
	coord_int16 bc

	; view rect centre
	ld a, [wScroll.x + 0]
	add 160 / 2 :: ld e, a
	ld a, [wScroll.x + 1]
	adc e :: sub e :: ld d, a

	coord_sub bc, de
	entity_index Entity_DispX
	ld a, c :: add 160 / 2 :: ld [hl], a
	call _ScrollFenceThing
	ld [wScroll.dx], a

	ret


;; Scroll view if target is more than this distance from the screen centre.
def SCROLL_FENCE equ 16


;; @param C: dCentre -- target position relative to view centre
;; @ret A: scroll delta
_ScrollFenceThing:
	ld a, c
	and a
	ret z
	rlca
	jr c, .negative
.positive
	ld a, c
	sub SCROLL_FENCE
	ret nc
	xor a
	ret
.negative
	ld a, c
	sub -SCROLL_FENCE
	ret c
	xor a
	ret


/*
;; @param B: vkeys
PlayerFlap:
	; Keep the 'ctrl' field available in C, and save any changes made to it down below.
	ld a, [wEntity + Entity_Ctrl] :: ld c, a

	; Flap!
	bit bVKEY_FLAP, b
	jr z, :+
	ld a, FLAP_FULL
	jr .flap
:

	; Autoflap!
	bit bVKEY_AUTOFLAP, b
	jr z, :+
	ld a, c :: and mENTCTRL_FLAP
	cp AUTOFLAP_THRESHOLD
	jr nc, :+
	ld a, FLAP_FULL
	jr .flap
:
	jr .noflap

.flap:
	xor c :: and mENTCTRL_FLAP :: xor c
	ld c, a
	; @SFX?
	; @VFX
.noflap:

	ld hl, wEntity + Entity_Ctrl
	ld a, c :: ld [hl+], a
	ret
*/


;; Read input, update vkeys
;; @ret B: vkeys
;; @ret D,E: Drive Y,X
;; @mut: AF, BC, DE
PlayerInputUpdate:
;	ld de, (12 << 8) | 17
	ld de, (5 << 8) | 7
;	ld de, (2 << 8) | 3
;	ld de, (1 << 8) | 2
	ldh a, [hKeys] :: ld b, a
	call Vecdir8FromKeys
	ld a, d :: ldh [hPlayerDriveY], a
	ld a, e :: ldh [hPlayerDriveX], a

	; B will hold the new vkeys state...
	ld b, 0

	; autoflap
	bit PADB_A, c
	jr z, :+
	set bVKEY_AUTOFLAP, b
:

	; manual flap
	ldh a, [hKeysPressed]
	bit PADB_A, a
	jr z, :+
	set bVKEY_FLAP, b
	res bVKEY_AUTOFLAP, b ; overrides autoflap
:

	ld a, b :: ld [wPlayer.vkeys], a
	ret

