include "hardware.inc"
include "sim/entity.rgbinc"
include "coord.rgbinc"
include "vis/diver.rgbinc"
include "banker.rgbinc"


def bVKEY_FLAP        equ 0
def bVKEY_AUTOFLAP    equ 1

def FLAP_FULL equ $0D
def FLAP_AUTO equ $0C
def AUTOFLAP_THRESHOLD equ $02

def THRUST_TICK equ $07

rsreset
def Player_vis rb szVisDiver
;def Player_vkeys rb 1
;def Player_ydrive rb 1
;def Player_xdrive rb 1
def szPlayer rb 0
assert szPlayer <= szEntityUsr0, "Player struct exceeds Entity Usr0 allocation. ({d:szPlayer} > {d:szEntityUsr0})"


section "wPlayer", wram0
wPlayer::
	.vkeys: db
	;; Direct directional movement vector, Y axis
	.driveY: db
	;; 'Drive' movement control vector, X axis
	.driveX: db
	;; Entity index
	.ent:: db


section "Player", rom0
PlayerInit::
	xor a
	ld [wPlayer.vkeys], a
	ld [wPlayer.driveY], a
	ld [wPlayer.driveX], a
	ld a, $FF
	ld [wPlayer.ent], a
	ret


;; @param A: player entity index
;; @param BC: Y position
;; @param DE: X position
;; @mut: AF, HL
PlayerSpawn::
	ld [wPlayer.ent], a

	ld a, [wPlayer.ent]
	call EntityAt

	ld a, ENTINFOF_ALIVE | $01
	ld [hl+], a
	xor a :: ld [hl+], a

	xor a
	ld [hl+], a ; accx
	ld [hl+], a ; velx
	ld a, e :: ld [hl+], a ; posx.lo
	ld a, d :: ld [hl+], a ; posx.hi
	xor a
	ld [hl+], a ; accy
	ld [hl+], a ; vely
	ld a, c :: ld [hl+], a ; posy.lo
	ld a, b :: ld [hl+], a ; posy.hi

	; FnUpdate impl
	ld de, EntityFnUpdateMoveCollide
	ld b, bank(EntityFnUpdateMoveCollide)
	ld a, [wPlayer.ent]
	call EntitySetFnUpdate

	; FnThink impl
	ld de, PlayerThink
	ld b, bank(PlayerThink)
	ld a, [wPlayer.ent]
	call EntitySetFnThink

	; FnRender impl
	ld de, PlayerRender
	ld b, bank(PlayerRender)
	ld a, [wPlayer.ent]
	call EntitySetFnRender

	; vis struct in Usr0
	ld a, [wPlayer.ent]
	call EntityGetUsr0
		wrambpush bank(wEntityUsr0)
	assert Player_vis == 0
	call VisDiverReset
		wrambpop

	ret


;; Entity impl FnThink for player entity controller.
;; @mut: AF, BC, D, HL
PlayerThink:
	call PlayerInputUpdate

	; get entity pointer
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a

	entity_index Entity_Ctrl
	; set NOGRAV if active directional input.
	res bENTCTRL_NOGRAV, [hl]
	ld a, e :: or d
	jr z, :+
	set bENTCTRL_NOGRAV, [hl]
:

	; Directional movement
	ldh a, [hSim.tick]
	and THRUST_TICK
	ret nz

	entity_index Entity_AccY
	ld [hl], d
	entity_index Entity_AccX
	ld [hl], e

	ret


PlayerRender:
	; get entity pointer
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a

	; After scrolling, adjust display position
	entity_index Entity_DispX
	ld a, [hl+] :: ld c, a
	ldh a, [hScrollAppliedX]
	cpl :: inc a :: add c :: add ENT_SPRITE_X_OFF :: ld c, a
	assert Entity_DispY == Entity_DispX + 1
	ld a, [hl+] :: ld b, a
	ldh a, [hScrollAppliedY]
	cpl :: inc a :: add b :: add ENT_SPRITE_Y_OFF :: ld b, a

		push bc

	; Update vis ctl speed
	ld b, 0
	ld a, [wPlayer.driveY]
	ld c, a
	ld a, [wPlayer.driveX]
	or c
	jr z, .nodrive
	entity_index Entity_VelY
	ld a, [hl]
	call AbsS8
	ld b, a
	entity_index Entity_VelX
	ld a, [hl]
	call AbsS8
	or b
	srl a
	cp VisDiverCtl_SPEED+1
	jr c, :+
	ld a, VisDiverCtl_SPEED
:
	ld b, a
.nodrive
	; player.vis (in entity usr0)
	ldh a, [hEntityActive.usr0 + 0] :: ld l, a
	ldh a, [hEntityActive.usr0 + 1] :: ld h, a

	; ctl.HEADING
	ldh a, [hKeys]
	and VisDiverCtl_HEADING
	or b
	call VisDiverSetCtl

		pop bc

	ldh a, [hEntityActive.usr0 + 0] :: ld l, a
	ldh a, [hEntityActive.usr0 + 1] :: ld h, a
	; update position
	ld a, b :: ld [hl+], a
	ld a, c :: ld [hl-], a
	; update/display
	jp VisDiverUpdate


PlayerViewTarget::
	ld a, [wPlayer.ent]
	call EntityAt
	ret nc

	; player entity Y position
	entity_index Entity_PosY
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld b, a
	coord_int16 bc

	; view rect centre
	ld a, [wScroll.y + 0]
	add 144 / 2 :: ld e, a
	ld a, [wScroll.y + 1]
	adc e :: sub e :: ld d, a

	coord_sub bc, de
	entity_index Entity_DispY
	ld a, c :: add 144 / 2 :: ld [hl], a
	call _ScrollFenceThing
	ld [wScroll.dy], a

	; player entity X position
	entity_index Entity_PosX
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld b, a
	coord_int16 bc

	; view rect centre
	ld a, [wScroll.x + 0]
	add 160 / 2 :: ld e, a
	ld a, [wScroll.x + 1]
	adc e :: sub e :: ld d, a

	coord_sub bc, de
	entity_index Entity_DispX
	ld a, c :: add 160 / 2 :: ld [hl], a
	call _ScrollFenceThing
	ld [wScroll.dx], a

	ret


;; Scroll view if target is more than this distance from the screen centre.
def SCROLL_FENCE equ 16


;; @param C: dCentre -- target position relative to view centre
;; @ret A: scroll delta
_ScrollFenceThing:
	ld a, c
	and a
	ret z
	rlca
	jr c, .negative
.positive
	ld a, c
	sub SCROLL_FENCE
	ret nc
	xor a
	ret
.negative
	ld a, c
	sub -SCROLL_FENCE
	ret c
	xor a
	ret


/*
;; @param B: vkeys
PlayerFlap:
	; Keep the 'ctrl' field available in C, and save any changes made to it down below.
	ld a, [wEntity + Entity_Ctrl] :: ld c, a

	; Flap!
	bit bVKEY_FLAP, b
	jr z, :+
	ld a, FLAP_FULL
	jr .flap
:

	; Autoflap!
	bit bVKEY_AUTOFLAP, b
	jr z, :+
	ld a, c :: and mENTCTRL_FLAP
	cp AUTOFLAP_THRESHOLD
	jr nc, :+
	ld a, FLAP_FULL
	jr .flap
:
	jr .noflap

.flap:
	xor c :: and mENTCTRL_FLAP :: xor c
	ld c, a
	; @SFX?
	; @VFX
.noflap:

	ld hl, wEntity + Entity_Ctrl
	ld a, c :: ld [hl+], a
	ret
*/


;; Read input, update vkeys
;; @ret B: vkeys
;; @ret D,E: Drive Y,X
;; @mut: AF, BC, DE
PlayerInputUpdate:
;	ld de, (12 << 8) | 17
	ld de, (5 << 8) | 7
;	ld de, (2 << 8) | 3
;	ld de, (1 << 8) | 2
	ldh a, [hKeys] :: ld b, a
	call Vecdir8FromKeys
	ld a, d :: ld [wPlayer.driveY], a
	ld a, e :: ld [wPlayer.driveX], a

	; B will hold the new vkeys state...
	ld b, 0

	; autoflap
	bit PADB_A, c
	jr z, :+
	set bVKEY_AUTOFLAP, b
:

	; manual flap
	ldh a, [hKeysPressed]
	bit PADB_A, a
	jr z, :+
	set bVKEY_FLAP, b
	res bVKEY_AUTOFLAP, b ; overrides autoflap
:

	ld a, b :: ld [wPlayer.vkeys], a
	ret

