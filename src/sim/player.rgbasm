include "hardware.inc"
include "sim/entity.rgbinc"
include "coord.rgbinc"


def bVKEY_FLAP        equ 0
def bVKEY_AUTOFLAP    equ 1

def FLAP_FULL equ $0D
def FLAP_AUTO equ $0C
def AUTOFLAP_THRESHOLD equ $02


section "wPlayer", wram0
wPlayer::
	.vkeys: db
	.ent: dw


section "hPlayer", hram
;; Direct directional movement vector, Y axis
hPlayerDriveY: db
;; 'Drive' movement control vector, X axis
hPlayerDriveX: db


section "Player", rom0
PlayerInit::
	xor a
	ld [wPlayer.vkeys], a
	ldh [hPlayerDriveY], a
	ldh [hPlayerDriveX], a
	ld a, $FF
	ld [wPlayer.ent+0], a
	ld [wPlayer.ent+1], a
	ret


;; @param HL: player entity
;; @mut: AF, HL
PlayerSpawn::
	ld a, l :: ld [wPlayer.ent+0], a
	ld a, h :: ld [wPlayer.ent+1], a

	ld a, ENTINFOF_ALIVE | $01
	ld [hl+], a
	ld a, ENTITY_COUNT_MAX
	sub c
	ld [hl+], a
	; accx
	ld a, 40 :: ld [hl+], a
	; velx
	ld a, 40 :: ld [hl+], a
	; posx
	coord_ld_hli_int 8 * 6 ;(WORLD_ORIGIN >> 4) + 90
	; accy
	ld a, -20 :: ld [hl+], a
	; vely
	ld a, 20 :: ld [hl+], a
	; posy
	coord_ld_hli_int 8 * 4 ;(WORLD_ORIGIN >> 4) + 50

	ret


;; Player entity controller: per-tick update function
;; @mut: AF, BC, D, HL
PlayerUpdate::
	ld hl, wPlayer.ent
	ld a, [hl+]
	ld h, [hl]
	ld l, a
	; if .ent == $FFFF, abort
	and h :: inc a
	ret z
	call PlayerInputUpdate
	entity_index Entity_Ctrl
	; set NOGRAV if active directional input.
	res bENTCTRL_NOGRAV, [hl]
	ld a, e :: or d
	jr z, :+
	set bENTCTRL_NOGRAV, [hl]
:
	; Directional movement
	entity_index Entity_AccY
	ld [hl], d
	entity_index Entity_AccX
	ld [hl], e

	ret

/*
;; @param B: vkeys
PlayerFlap:
	; Keep the 'ctrl' field available in C, and save any changes made to it down below.
	ld a, [wEntity + Entity_Ctrl] :: ld c, a

	; Flap!
	bit bVKEY_FLAP, b
	jr z, :+
	ld a, FLAP_FULL
	jr .flap
:

	; Autoflap!
	bit bVKEY_AUTOFLAP, b
	jr z, :+
	ld a, c :: and mENTCTRL_FLAP
	cp AUTOFLAP_THRESHOLD
	jr nc, :+
	ld a, FLAP_FULL
	jr .flap
:
	jr .noflap

.flap:
	xor c :: and mENTCTRL_FLAP :: xor c
	ld c, a
	; @SFX?
	; @VFX
.noflap:

	ld hl, wEntity + Entity_Ctrl
	ld a, c :: ld [hl+], a
	ret
*/


;; Read input, update vkeys
;; @ret B: vkeys
;; @ret D,E: Drive Y,X
;; @mut: AF, BC, DE
PlayerInputUpdate:
;	ld de, (12 << 8) | 17
;	ld de, (5 << 8) | 7
	ld de, (2 << 8) | 3
	ldh a, [hKeys] :: ld b, a
	call Vecdir8FromKeys
	ld a, d :: ldh [hPlayerDriveY], a
	ld a, e :: ldh [hPlayerDriveX], a

	; B will hold the new vkeys state...
	ld b, 0

	; autoflap
	bit PADB_A, c
	jr z, :+
	set bVKEY_AUTOFLAP, b
:

	; manual flap
	ldh a, [hKeysPressed]
	bit PADB_A, a
	jr z, :+
	set bVKEY_FLAP, b
	res bVKEY_AUTOFLAP, b ; overrides autoflap
:

	ld a, b :: ld [wPlayer.vkeys], a
	ret

