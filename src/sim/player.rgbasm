include "hardware.inc"
include "sim/entity.rgbinc"
include "coord.rgbinc"
include "vis/diver.rgbinc"
include "banker.rgbinc"


;; Ticks between applying drive/accel.
def DRIVE_INTERVAL equ 2


rsreset
def Player_vis rb szVisDiver
def szPlayer rb 0
assert szPlayer <= szEntityUsr0, "Player struct exceeds Entity Usr0 allocation. ({d:szPlayer} > {d:szEntityUsr0})"


section "wPlayer", wram0
wPlayer::
	;; Direct directional movement vector, Y axis
	.driveY: db
	;; 'Drive' movement control vector, X axis
	.driveX: db
	;; Entity index
	.ent:: db
	.inputDir: db
	.driveTimer: db


section "Player", rom0
PlayerInit::
	ld a, $FF
	ld [wPlayer.ent], a
	ret


;; @param A: player entity index
;; @param BC: Y position
;; @param DE: X position
;; @mut: AF, BC, DE, HL
PlayerSpawn::
	ld [wPlayer.ent], a

	xor a
	ld [wPlayer.driveY], a
	ld [wPlayer.driveX], a
	ld [wPlayer.inputDir], a
	ld a, DRIVE_INTERVAL
	ld [wPlayer.driveTimer], a

	ld a, [wPlayer.ent]
	call EntityAt

	ld a, ENTINFOF_OCCUPIED | ENTINFOF_ALIVE | $01
	ld [hl+], a
	ld a, ENTCTRL_DRAG_A
	ld [hl+], a

	xor a
	ld [hl+], a ; accx
	ld [hl+], a ; velx
	ld a, e :: ld [hl+], a ; posx.lo
	ld a, d :: ld [hl+], a ; posx.hi
	xor a
	ld [hl+], a ; accy
	ld [hl+], a ; vely
	ld a, c :: ld [hl+], a ; posy.lo
	ld a, b :: ld [hl+], a ; posy.hi

	; FnUpdate impl
	ld de, EntityFnUpdateMoveCollide
	ld b, bank(EntityFnUpdateMoveCollide)
	ld a, [wPlayer.ent]
	call EntitySetFnUpdate

	; FnThink impl
	ld de, PlayerThink
	ld b, bank(PlayerThink)
	ld a, [wPlayer.ent]
	call EntitySetFnThink

	; FnRender impl
	ld de, PlayerRender
	ld b, bank(PlayerRender)
	ld a, [wPlayer.ent]
	call EntitySetFnRender

	; vis struct in Usr0
	ld a, [wPlayer.ent]
	call EntityGetUsr0
		wrambpush bank(wEntityUsr0)
	assert Player_vis == 0
	call VisDiverReset
		wrambpop

	ret


;; Entity impl FnThink for player entity controller.
;; @mut: AF, BC, D, HL
PlayerThink:
	ldh a, [hKeys]
	and $F0
	ld [wPlayer.inputDir], a

	ld hl, wPlayer.driveTimer
	dec [hl]
	ret nz
	ld a, DRIVE_INTERVAL :: ld [hl], a

	; update drive vector
	ld a, [wPlayer.inputDir] :: ld b, a
	ld de, (5 << 8) | 7
	call Vecdir8FromKeys
	ld a, d :: ld [wPlayer.driveY], a
	ld a, e :: ld [wPlayer.driveX], a

	; get entity pointer
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a
	entity_index Entity_AccY
	ld [hl], d
	entity_index Entity_AccX
	ld [hl], e

	entity_index Entity_Ctrl
	; set NOGRAV if active directional input.
	res bENTCTRL_NOGRAV, [hl]
	ld a, e :: or d
	jr z, :+
	set bENTCTRL_NOGRAV, [hl]
:

	ret


PlayerRender:
	; get entity pointer
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a

	; After scrolling, adjust display position
	entity_index Entity_DispX
	ld a, [hl+] :: ld c, a
	ldh a, [hScrollAppliedX]
	cpl :: inc a :: add c :: add ENT_SPRITE_X_OFF :: ld c, a
	assert Entity_DispY == Entity_DispX + 1
	ld a, [hl+] :: ld b, a
	ldh a, [hScrollAppliedY]
	cpl :: inc a :: add b :: add ENT_SPRITE_Y_OFF :: ld b, a

		push bc

	; Update vis ctl speed
	ld b, 0
	ld a, [wPlayer.driveY]
	ld c, a
	ld a, [wPlayer.driveX]
	or c
	jr z, .nodrive
	entity_index Entity_VelY
	ld a, [hl]
	call AbsS8
	ld b, a
	entity_index Entity_VelX
	ld a, [hl]
	call AbsS8
	or b
	srl a
	cp VisDiverCtl_SPEED+1
	jr c, :+
	ld a, VisDiverCtl_SPEED
:
	ld b, a
.nodrive
	; player.vis (in entity usr0)
	ldh a, [hEntityActive.usr0 + 0] :: ld l, a
	ldh a, [hEntityActive.usr0 + 1] :: ld h, a

	; ctl.HEADING
	ldh a, [hKeys]
	and VisDiverCtl_HEADING
	or b
	call VisDiverSetCtl

		pop bc

	ldh a, [hEntityActive.usr0 + 0] :: ld l, a
	ldh a, [hEntityActive.usr0 + 1] :: ld h, a
	; update position
	ld a, b :: ld [hl+], a
	ld a, c :: ld [hl-], a
	; update/display
	jp VisDiverUpdate


PlayerViewTarget::
	ld a, [wPlayer.ent]
	call EntityAt
	ret nc

	; player entity Y position
	entity_index Entity_PosY
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld b, a
	coord_int16 bc

	; view rect centre
	ld a, [wScroll.y + 0]
	add 144 / 2 :: ld e, a
	ld a, [wScroll.y + 1]
	adc e :: sub e :: ld d, a

	coord_sub bc, de
	entity_index Entity_DispY
	ld a, c :: add 144 / 2 :: ld [hl], a
	call _ScrollFenceThing
	ld [wScroll.dy], a

	; player entity X position
	entity_index Entity_PosX
	ld a, [hl+] :: ld c, a
	ld a, [hl+] :: ld b, a
	coord_int16 bc

	; view rect centre
	ld a, [wScroll.x + 0]
	add 160 / 2 :: ld e, a
	ld a, [wScroll.x + 1]
	adc e :: sub e :: ld d, a

	coord_sub bc, de
	entity_index Entity_DispX
	ld a, c :: add 160 / 2 :: ld [hl], a
	call _ScrollFenceThing
	ld [wScroll.dx], a

	ret


;; Scroll view if target is more than this distance from the screen centre.
def SCROLL_FENCE equ 16


;; @param C: dCentre -- target position relative to view centre
;; @ret A: scroll delta
_ScrollFenceThing:
	ld a, c
	and a
	ret z
	rlca
	jr c, .negative
.positive
	ld a, c
	sub SCROLL_FENCE
	ret nc
	xor a
	ret
.negative
	ld a, c
	sub -SCROLL_FENCE
	ret c
	xor a
	ret

