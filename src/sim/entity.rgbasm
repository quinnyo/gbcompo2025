include "entity.rgbinc"


section "wEntity", wram0, align[8]
wEntity:: ds ENTITY_COUNT_MAX * Entity_size
_pad: ds 256 - (@ - wEntity)


section "Entity Testo", rom0
EntityTesto::
	ld hl, wEntity
	ld c, ENTITY_COUNT_MAX
:
	ld a, ENTINFOF_ALIVE | $01
	ld [hl+], a
	ld a, ENTITY_COUNT_MAX
	sub c
	ld [hl+], a
	; accx
	ld a, c
	inc a
	add a
	ld [hl+], a
	; velx
	xor a :: ld [hl+], a
	; posx
	xor a :: ld [hl+], a :: ld [hl+], a
	; accy
	ld a, -5 :: ld [hl+], a
	; vely
	xor a :: ld [hl+], a
	; posy
	xor a :: ld [hl+], a :: ld [hl+], a

	ld a, l
	and $F0
	add Entity_size
	ld l, a

	dec c
	jr nz, :-
	ret


section "Entity", rom0
EntityInit::
	ld hl, startof("wEntity")
	xor a
	ld c, a
:
	ld [hl+], a
	dec c
	jr nz, :-
	call EntityTesto
	ret


EntityUpdate::
	ld hl, wEntity
.loop
	push hl
	call _update_motion
	pop hl
	ld a, l
	add Entity_size
	ld l, a
	jr nz, .loop
	ret


; @param HL: entity address
; @mut: AF, BC, HL
_update_motion:
	bit ENTINFOB_ALIVE, [hl]
	ret z

	assert Entity_AccX == Entity_Info + 2
	inc l
	inc l

	; Motion (X)
	; accel x
	ld b, [hl]
	xor a
	ld [hl+], a
	; vel x
	ld a, [hl]
	; TODO: use correct friction level
	call _fric_7_8
	; velx += accelx - friction(velx)
	add b
	ld b, [hl] ; B = old vel
	ld [hl+], a
	; posx += (old)velx
	ld a, b
	add [hl]
	ld b, a
	ld [hl+], a
	adc [hl]
	sub b
	ld [hl+], a

	; Motion (Y)
	; TODO: use correct gravity
	ld a, GRAVITY_100
	; accel y
	add [hl]
	ld b, a
	xor a
	ld [hl+], a
	; vel y
	ld a, [hl]
	; TODO: use correct friction level
	call _fric_7_8
	; vely += accely - friction(vely)
	add b
	ld b, [hl] ; B = old vel
	ld [hl+], a
	; posy += (old)vely
	ld a, b
	add [hl]
	ld b, a
	ld [hl+], a
	adc [hl]
	sub b
	ld [hl+], a

	ret


; @param A: vel
; @ret A: friction(vel)
; @mut: AF, C
_fric_3_8:
	sra a
	sra a
	ld c, a ; 2/8
	sra a ; 1/8
	add c ; 3/8
	ret
; @param A: vel
; @ret A: friction(vel)
; @mut: AF, C
_fric_6_8:
	sra a
	ld c, a ; 4/8
	sra a ; 2/8
	add c ; 6/8
	ret
; @param A: vel
; @ret A: friction(vel)
; @mut: AF, C
_fric_7_8:
	ld c, a
	sra c
	sra c
	sra c
	sub c
	ret

