include "entity.rgbinc"
include "collide.rgbinc"
include "coord.rgbinc"
include "hardware.inc"
include "banker.rgbinc"


section "hSim", hram
hSim::
	.gravity:: db
	.tick:: db


section "hEntityActive", hram
;; Info about currently active/"open" entity
hEntityActive::
	.index:: db
	.state:: dw
	.usr0:: dw
	.ctrl:: db


section "wEntity", wram0, align[8]
wEntity:: ds ENTITY_COUNT_MAX * szEntity


section "wEntityFn", wram0, align[bitwidth(szEntityFn - 1)]
def szEntityFnTable equ ENTITY_COUNT_MAX * szEntityFn
;; EntityFn for each entity's FnUpdate
wEntityFnUpdate:: ds szEntityFnTable
;; EntityFn impl for each entity's FnThink
wEntityFnThink:: ds szEntityFnTable
;; EntityFn impl FnRender
wEntityFnRender:: ds szEntityFnTable


section "wEntityUsr0", wramx, align[bitwidth(szEntityUsr0 - 1)]
;; Per-Entity implementor-use area.
;; @aligned: full per-instance
wEntityUsr0:: ds ENTITY_COUNT_MAX * szEntityUsr0


section "Entity", rom0
EntityInit::
	ld hl, wEntity
	ld b, ENTITY_COUNT_MAX
.entity_pool_loop
	ld c, szEntity
:
	ld [hl+], a
	dec c
	jr nz, :-
	dec b
	jr nz, .entity_pool_loop

	ld a, GRAVITY_DEFAULT
	ldh [hSim.gravity], a
	xor a
	ldh [hSim.tick], a

	ld hl, startof("hEntityActive")
	ld c, sizeof("hEntityActive")
	xor a
	call MemFillSmall

	; Set all EntityFn to Dummy impl
	ld hl, startof("wEntityFn")
	ld e, l :: ld d, h
	ld a, bank(EntityFnDummy) :: ld [hl+], a
	xor a :: ld [hl+], a
	ld a, low(EntityFnDummy) :: ld [hl+], a
	ld a, high(EntityFnDummy) :: ld [hl+], a
	ld c, szEntityFn
	ld b, sizeof("wEntityFn") / szEntityFn - 1
	jp MemFillRepeat


; @mut: AF, BC, DE, HL
EntityUpdate::
		; Preserve bank out here -- allow lightweight switching in the loop.
		rombopen
		wrambopen

	; entity index
	ld b, 0
.loop
	ld a, b :: call EntityActiveSelect

	; only process ALIVE entities
	ld a, [hl+]
	cpl
	and ENTINFOF_OCCUPIED | ENTINFOF_ALIVE
	jr nz, .next

	; FnThink
	ld hl, wEntityFnThink / szEntityFn
	call EntityActiveInvoke

	; FnUpdate
	ld hl, wEntityFnUpdate / szEntityFn
	call EntityActiveInvoke

.next
	ldh a, [hEntityActive.index] :: ld b, a
	inc b
	cp ENTITY_COUNT_MAX - 1
	jr c, .loop

	ldh a, [hSim.tick]
	inc a
	ldh [hSim.tick], a
	ret


; @mut: AF, BC, DE, HL
EntityRender::
		; Preserve bank out here -- allow lightweight switching in the loop.
		rombopen
		wrambopen

	; entity index
	ld b, 0
.loop
	ld a, b :: call EntityActiveSelect

	; only process ALIVE and INVIEW entities
	ld a, [hl+]
	cpl
	and ENTINFOF_OCCUPIED | ENTINFOF_ALIVE | ENTINFOF_INVIEW
	jr nz, .next

	; FnRender
	ld hl, wEntityFnRender / szEntityFn
	call EntityActiveInvoke

.next
	ldh a, [hEntityActive.index] :: ld b, a
	inc b
	cp ENTITY_COUNT_MAX - 1
	jr c, .loop

	ret


section "EntityActiveInvoke", rom0
;; Invoke an impl (EntityFn) of the active entity.
;; NOTE: ROMX and WRAMX banks will be changed.
;; @param HL: function table start address divided by szEntityFn
;; @mut: AF, HL, (BC), (DE)
EntityActiveInvoke:
	ldh a, [hEntityActive.index]
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	assert szEntityFn == 4
	add hl, hl
	add hl, hl
		; Target function bank
		rombsel [hl+]
	; skip second byte ~~~ wEntityFn is aligned so inc low byte alone is OK
	inc l
		wrambsel bank(wEntityUsr0)
	ld a, [hl+]
	ld h, [hl]
	ld l, a
	jp hl


section "EntityActiveSelect", rom0
;; Set the active entity, update hEntityActive.
;; @param A: index of entity to select
;; @ret HL: Entity state pointer
;; @mut: AF, HL
EntityActiveSelect::
	ldh [hEntityActive.index], a

	ld hl, wEntityUsr0 / szEntityUsr0
	ldh a, [hEntityActive.index]
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	assert szEntityUsr0 == 16
	add hl, hl
	add hl, hl
	add hl, hl
	add hl, hl
	ld a, l :: ldh [hEntityActive.usr0 + 0], a
	ld a, h :: ldh [hEntityActive.usr0 + 1], a

	; get entity state pointer
	assert szEntity == 16
	ldh a, [hEntityActive.index]
	swap a ; mul 16
	ldh [hEntityActive.state + 0], a
	ld l, a
	ld a, high(wEntity)
	ldh [hEntityActive.state + 1], a
	ld h, a

	ld a, [hl+] ; Info
	ld a, [hl-] ; Ctrl
	ldh [hEntityActive.ctrl], a
	ret


section "EntityActiveSelectEmpty", rom0
;; Select the first unoccupied entity slot, if any.
;; @ret HL: address of empty slot
;; @ret C: index
;; @ret F.C: set if successful
;; @mut: AF, C, HL
EntityActiveSelectEmpty::
	ld hl, wEntity + szEntity * ENTITY_AUTO_ASSIGN_START
	ld c, ENTITY_AUTO_ASSIGN_START
:
	ld a, [hl]
	and ENTINFOF_OCCUPIED
	jr z, .ok

	inc c
	ld a, c
	cp ENTITY_COUNT_MAX
	ret nc

	ld a, szEntity
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	jr :-
.ok
	ld a, l :: ldh [hEntityActive.state + 0], a
	ld a, h :: ldh [hEntityActive.state + 1], a
	ld a, c :: ldh [hEntityActive.index], a
		push hl
	call EntityGetUsr0
	ld a, l :: ldh [hEntityActive.usr0 + 0], a
	ld a, h :: ldh [hEntityActive.usr0 + 1], a
		pop hl
	scf
	ret


section "EntityGetFn", rom0
;; Get a pointer to one of an entity's impl functions.
;; @param A: entity index
;; @param HL: function table start address divided by szEntityFn
;; @ret HL: pointer to the EntityFn at given index
;; @mut: AF, HL
EntityGetFn::
	; at(i) = table + i * szItem = (i + table / szItem) * szItem
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	assert szEntityFn == 4
	add hl, hl
	add hl, hl
	ret


;; Get a pointer to an entity's FnUpdate impl function.
;; @param A: entity index
;; @ret HL: pointer to the EntityFn at given index
;; @mut: AF, HL
EntityGetFnUpdate::
	ld hl, wEntityFnUpdate / szEntityFn
	jr EntityGetFn


;; Get a pointer to an entity's FnThink impl function.
;; @param A: entity index
;; @ret HL: pointer to the EntityFn at given index
;; @mut: AF, HL
EntityGetFnThink::
	ld hl, wEntityFnThink / szEntityFn
	jr EntityGetFn


;; Get a pointer to an entity's FnRender impl function.
;; @param A: entity index
;; @ret HL: pointer to the EntityFn at given index
;; @mut: AF, HL
EntityGetFnRender::
	ld hl, wEntityFnRender / szEntityFn
	jr EntityGetFn


section "EntitySetFn", rom0
;; Set an entity's impl function.
;; @param A: entity index
;; @param HL: function table start address divided by szEntityFn
;; @param DE: target address
;; @param B: target bank
;; @mut: AF, HL
EntitySetFn::
	; at(i) = table + i * szItem = (i + table / szItem) * szItem
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	assert szEntityFn == 4
	add hl, hl
	add hl, hl

	ld a, b :: ld [hl+], a ; bank
	inc l ; (unused)
	ld a, e :: ld [hl+], a ; target.lo
	ld [hl], d ; target.hi
	ret


;; Set an entity's FnUpdate impl.
;; @param A: entity index
;; @param DE: target address
;; @param B: target bank
;; @mut: AF, HL
EntitySetFnUpdate::
	ld hl, wEntityFnUpdate / szEntityFn
	jr EntitySetFn


;; Set an entity's FnThink impl.
;; @param A: entity index
;; @param DE: target address
;; @param B: target bank
;; @mut: AF, HL
EntitySetFnThink::
	ld hl, wEntityFnThink / szEntityFn
	jr EntitySetFn


;; Set an entity's FnRender impl.
;; @param A: entity index
;; @param DE: target address
;; @param B: target bank
;; @mut: AF, HL
EntitySetFnRender::
	ld hl, wEntityFnRender / szEntityFn
	jr EntitySetFn


section "EntityAt", rom0
;; Get a pointer to the Entity struct at the given index.
;; @param A: entity index
;; @ret HL: pointer to the Entity
;; @ret F.C: set if successful (i.e. index in range)
;; @mut: AF, HL
EntityAt::
	cp ENTITY_COUNT_MAX
	ret nc

	ld hl, wEntity / szEntity
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	assert szEntity == 16
	add hl, hl
	add hl, hl
	add hl, hl
	add hl, hl
	scf ; ret F.C
	ret


section "EntityGetUsr0", rom0
;; Returns a pointer to an Entity's block in wEntityUsr0.
;; @param A: entity index
;; @param HL: user region start address divided by szEntityUsr0
;; @ret HL: pointer to the user region
;; @mut: AF, HL
EntityGetUsr0::
	ld hl, wEntityUsr0 / szEntityUsr0
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	assert szEntityUsr0 == 16
	add hl, hl
	add hl, hl
	add hl, hl
	add hl, hl
	ret


section "EntityFnDummy", romx
;; Entity impl that does nothing.
EntityFnDummy::
	ret


section "EntityFnUpdate", romx
;; Default FnUpdate impl -- integrate, apply gravity, drag, do motion with collide
EntityFnUpdateMoveCollide::
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a

	; Update motion X, zero constant accel
	entity_index Entity_AccX
	xor a :: call _velocity_update
	ld a, b :: ldh [hCollide.vx], a
	ld a, [hl+] :: ldh [hCollide.px+0], a
	ld a, [hl+] :: ldh [hCollide.px+1], a

	; Update motion Y
	call _get_gravity :: ld b, a
	entity_index Entity_AccY
	ld a, b :: call _velocity_update
	ld a, b :: ldh [hCollide.vy], a
	ld a, [hl+] :: ldh [hCollide.py+0], a
	ld a, [hl+] :: ldh [hCollide.py+1], a

	push hl
	call CollidePointMotion
	pop hl

	entity_index Entity_PosX
	ldh a, [hCollide.px+0] :: ld [hl+], a
	ld e, a
	ldh a, [hCollide.px+1] :: ld [hl+], a
	ld d, a
	; dispX
	coord_int16 de
	ld a, [wScroll.x + 0] :: ld c, a
	ld a, [wScroll.x + 1] :: ld b, a
	ld a, e :: sub c :: ld e, a
	ld a, d :: sbc b :: ld d, a

	entity_index Entity_PosY
	ldh a, [hCollide.py+0] :: ld [hl+], a
	ld c, a
	ldh a, [hCollide.py+1] :: ld [hl+], a
	ld b, a
	; dispY
	coord_int16 bc
		push de
	ld a, [wScroll.y + 0] :: ld e, a
	ld a, [wScroll.y + 1] :: ld d, a
	ld a, c :: sub e :: ld c, a
	ld a, b :: sbc d :: ld b, a
		pop de

	entity_index Entity_Info
	res ENTINFOB_INVIEW, [hl]
	call SprxTestVisibility
	jr nc, :+
	; visible
	set ENTINFOB_INVIEW, [hl]
	entity_index Entity_DispX
	ld a, c :: ld [hl+], a
	ld a, e :: ld [hl+], a
:

	ldh a, [hCollide.result]
	bit bCollideResult_SOLID, a
	ret z

	ld e, a
	bit bCollideResult_X, e
	jr z, :+
		entity_index Entity_VelX
		xor a :: ld [hl+], a
:
	bit bCollideResult_Y, e
	jr z, :+
		entity_index Entity_VelY
		xor a :: ld [hl+], a
:

	ret


;; FnUpdate impl that performs the same motion as the default impl with no collision.
EntityFnUpdateMotionOnly::
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a

	; Update motion X, zero constant accel
	entity_index Entity_AccX
	xor a :: call _velocity_update
	ld e, b :: call _apply_step

	; view dots X position
	coord_int16 bc
	ld a, [wScroll.x + 0] :: ld e, a
	ld a, [wScroll.x + 1] :: ld d, a
	ld a, c :: sub e :: ld c, a
	ld a, b :: sbc d :: ld b, a
		push bc

	; Update motion Y
	call _get_gravity :: ld b, a
	entity_index Entity_AccY
	ld a, b :: call _velocity_update
	ld e, b :: call _apply_step

	; view dots Y position
	coord_int16 bc
	ld a, [wScroll.y + 0] :: ld e, a
	ld a, [wScroll.y + 1] :: ld d, a
	ld a, c :: sub e :: ld c, a
	ld a, b :: sbc d :: ld b, a
		pop de ; X

	; Update display position, visibility
	entity_index Entity_Info
	res ENTINFOB_INVIEW, [hl]
	call SprxTestVisibility
	jr nc, :+
	; visible
	set ENTINFOB_INVIEW, [hl]
	entity_index Entity_DispX
	ld a, c :: ld [hl+], a ; DispX
	ld a, b :: ld [hl+], a ; DispY
:

	ret


;; Add a delta to entity's position
;; @param HL: pointer to entity position
;; @param E: step
;; @ret BC: updated position
;; @mut: AF, BC
_apply_step:
	ld a, [hl+] :: ld c, a
	ld a, [hl-] :: ld b, a

	; Update position (16 bit + signed 8 bit)
	ld a, e
	add c
	ld c, a
	adc b
	rl e ; Set F.C from sign of velocity
	sbc c
	ld b, a

	ld a, c :: ld [hl+], a
	ld a, b :: ld [hl-], a

	ret


;; @param HL: Pointer to beginning of an Entity motion block.
;; @param A: constant accel
;; @ret B: velocity for the current frame
;; @ret C: updated velocity
;; @mut: AF, BC, HL
_velocity_update:
	; combine accel with accumulated accel
	ld b, a
	ld c, [hl]
	call AddS8_sat
	; clear accel accumulator
	xor a :: ld [hl+], a

	; Apply accel (v + a)
	ld b, [hl]
	call AddS8_sat

	ldh a, [hEntityActive.ctrl]
	and ENTCTRL_DRAG :: ld e, a
	ld b, c :: call Drag1
	ld b, d :: call AddS8_sat
	ld de, SPEED_RANGE_CLAMP_PARAM
	ld b, c
	call ClampS8
	ld a, b :: ld [hl+], a
	ret


;; Get gravity accel for an entity
;; @ret A: gravity accel to apply
;; @mut: AF
_get_gravity:
	ldh a, [hEntityActive.ctrl]
	and ENTCTRL_NOGRAV
	jr nz, .nograv
	ldh a, [hSim.tick]
	and SIM_GRAVITY_TICK
	jr nz, .nograv
	ldh a, [hSim.gravity]
	ret
.nograv
	xor a
	ret


pushs "Drag16", romx, align[8]
;; gendrag(cd=1.30, A=44.4, m=2.10, v=1,128, yoffset=1.0, exp=3.0)
Drag16_A:: db 1, 1, 1, 2, 3, 5, 8, 13, 18, 25, 34, 45, 58, 73, 91, 111

pops ; Drag16


pushs "Drag", rom0
;; 1D drag very approximation
;; @param B: vel
;; @param E: drag model/curve selection
;; @ret D: drag
;; @mut: AF, DE
Drag1::
	ld d, 0 ; zero drag
	; zero vel?
	ld a, b
	and a
	ret z
	; drag disabled?
	ld a, e
	cp ENTCTRL_DRAG_NONE
	ret nc

	swap e ; mul 16 to get low byte of drag table

	; divide abs(vel) to get LUT index [0..16)
	ld a, b
	call AbsS8
	assert 127 >> DRAGTAB_INPUT_DIVS <= $0F
	rept DRAGTAB_INPUT_DIVS
		rrca
	endr
	and $0F
	add e :: ld e, a

		rombpush bank("Drag16")
	ld d, high(startof("Drag16"))
	ld a, [de]
	ld d, a
		rombpop
	ld a, d
	; sign(drag) = -sign(vel)
	bit 7, b
	ret nz
	xor a :: sub d :: ld d, a
	ret

pops ; Drag

