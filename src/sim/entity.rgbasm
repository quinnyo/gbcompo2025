include "entity.rgbinc"
include "collide.rgbinc"
include "coord.rgbinc"
include "banker.rgbinc"


section "hSim", hram
hSim::
	.gravity:: db
	.tick:: db


section "hEntityActive", hram
;; Info about currently active/"open" entity
hEntityActive::
	.index:: db
	.state:: dw


section "wEntity", wram0, align[8]
wEntity:: ds ENTITY_COUNT_MAX * szEntity


section "wEntityFn", wram0, align[bitwidth(szEntityFn)]
;; EntityFn for each entity's FnUpdate
wEntityFnUpdate:: ds ENTITY_COUNT_MAX * szEntityFn


section "Entity", rom0
EntityInit::
	ld hl, wEntity
	ld b, ENTITY_COUNT_MAX
.entity_pool_loop
	ld c, szEntity
:
	ld [hl+], a
	dec c
	jr nz, :-
	dec b
	jr nz, .entity_pool_loop

	ld a, GRAVITY_DEFAULT
	ldh [hSim.gravity], a
	xor a
	ldh [hSim.tick], a

	ld hl, startof("hEntityActive")
	ld c, sizeof("hEntityActive")
	xor a
	call MemFillSmall

	ld hl, wEntityFnUpdate
	ld c, ENTITY_COUNT_MAX
:
	assert szEntityFn == 4
	ld a, bank(EntityFnUpdateDefault) :: ld [hl+], a
	xor a :: ld [hl+], a
	ld a, low(EntityFnUpdateDefault) :: ld [hl+], a
	ld a, high(EntityFnUpdateDefault) :: ld [hl+], a
	dec c
	jr nz, :-

	ret


; @mut: AF, BC, DE, HL
EntityUpdate::
		; Preserve bank out here -- allow lightweight switching in the loop.
		rombopen
	; all entities have the same high address
	assert sizeof("wEntity") == 256
	ld a, high(wEntity) :: ldh [hEntityActive.state + 1], a
	; entity index
	ld b, 0
.loop
	ld a, b :: ldh [hEntityActive.index], a

	; get entity state pointer
	assert szEntity == 16
	swap a ; mul 16
	ldh [hEntityActive.state + 0], a
	ld l, a
	ld h, high(wEntity)

	; only process ALIVE entities
	bit ENTINFOB_ALIVE, [hl] :: jr z, .next

	; get ent's FnUpdate
	assert szEntityFn == 4
	ld a, b

	ld hl, wEntityFnUpdate >> 2
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	add hl, hl
	add hl, hl

		; Target function bank
		rombsel [hl+]
	; skip second byte ~~~ wEntityFn is aligned so inc low byte alone is OK
	inc l
	rst RST_CallPtrPtr

.next
	ldh a, [hEntityActive.index] :: ld b, a
	inc b
	cp ENTITY_COUNT_MAX - 1
	jr c, .loop

	ldh a, [hSim.tick]
	inc a
	ldh [hSim.tick], a
	ret


section "EntityFnUpdateDefault", romx
;; Default FnUpdate impl -- integrate, apply gravity, drag, do motion with collide
EntityFnUpdateDefault::
	ldh a, [hEntityActive.state + 0] :: ld l, a
	ldh a, [hEntityActive.state + 1] :: ld h, a

	; Update motion X, zero constant accel
	entity_index Entity_AccX
	xor a :: call _velocity_update
	ld de, SPEED_RANGE_CLAMP_PARAM
	call ClampS8
	ld a, b :: ldh [hCollide.vx], a
	ld a, [hl+] :: ldh [hCollide.px+0], a
	ld a, [hl+] :: ldh [hCollide.px+1], a

	; Update motion Y
	entity_index Entity_Ctrl
	call _get_gravity :: ld b, a
	entity_index Entity_AccY
	ld a, b :: call _velocity_update
	ld de, SPEED_RANGE_CLAMP_PARAM
	call ClampS8
	ld a, b :: ldh [hCollide.vy], a
	ld a, [hl+] :: ldh [hCollide.py+0], a
	ld a, [hl+] :: ldh [hCollide.py+1], a

	push hl
	call CollidePointMotion
	pop hl

	entity_index Entity_PosX
	ldh a, [hCollide.px+0] :: ld [hl+], a
	ld e, a
	ldh a, [hCollide.px+1] :: ld [hl+], a
	ld d, a
	; dispX
	coord_int16 de
	ld a, [wScroll.x + 0] :: ld c, a
	ld a, [wScroll.x + 1] :: ld b, a
	ld a, e :: sub c :: ld e, a
	ld a, d :: sbc b :: ld d, a

	entity_index Entity_PosY
	ldh a, [hCollide.py+0] :: ld [hl+], a
	ld c, a
	ldh a, [hCollide.py+1] :: ld [hl+], a
	ld b, a
	; dispY
	coord_int16 bc
		push de
	ld a, [wScroll.y + 0] :: ld e, a
	ld a, [wScroll.y + 1] :: ld d, a
	ld a, c :: sub e :: ld c, a
	ld a, b :: sbc d :: ld b, a
		pop de

	entity_index Entity_Info
	res ENTINFOB_INVIEW, [hl]
	call SprxTestVisibility
	jr nc, :+
	; visible
	set ENTINFOB_INVIEW, [hl]
	entity_index Entity_DispX
	ld a, c :: ld [hl+], a
	ld a, e :: ld [hl+], a
:

	ldh a, [hCollide.result]
	bit bCollideResult_SOLID, a
	ret z

	ld e, a
	bit bCollideResult_X, e
	jr z, :+
		entity_index Entity_VelX
		xor a :: ld [hl+], a
:
	bit bCollideResult_Y, e
	jr z, :+
		entity_index Entity_VelY
		xor a :: ld [hl+], a
:

	ret


;; @param HL: Pointer to beginning of an Entity motion block.
;; @param A: constant accel
;; @ret B: velocity for the current frame
;; @ret C: updated velocity
;; @mut: AF, BC, HL
_velocity_update:
	; combine accel with accumulated accel
	ld b, a
	ld c, [hl]
	call AddS8_sat
	; clear accel accumulator
	xor a :: ld [hl+], a

	; Apply accel (v + a)
	ld b, [hl]
	call AddS8_sat

	; Apply friction|drag but not on every frame!
	ldh a, [hSim.tick]
	and SIM_DRAG_TICK
	jr nz, .no_drag

	ld a, b :: call _fric_1_32
	add c :: ld c, a
.no_drag

	ld b, [hl]
	ld a, c :: ld [hl+], a

;; "Deflate" velocity -- scale the velocity down to get the position delta.
;; I can't remember exactly why this was the way it ended up, but I think it had
;; something to do with having only an hour or two before submission deadline.
;; TODO: ideally, not this?
;_velocity_deflate:
macro velocity_deflate_positive
	sra b :: sra b; :: sra b; :: sra b
endm
	ld a, b
	rlca
	jr nc, .positive
	xor a :: sub b :: ld b, a
	velocity_deflate_positive
	xor a :: sub b :: ld b, a
	ret
.positive
	velocity_deflate_positive
	ret


;; Get gravity accel for an entity
;; @param HL: pointer to entity ctrl field
;; @ret A: gravity accel to apply
;; @mut: AF
_get_gravity:
	bit bENTCTRL_NOGRAV, [hl]
	jr nz, .nograv
	ldh a, [hSim.tick]
	and SIM_GRAVITY_TICK
	jr nz, .nograv
	ldh a, [hSim.gravity]
	ret
.nograv
	xor a
	ret


;; Returns +/- 1, with the sign opposite the input velocity.
;; @param A: vel
;; @ret A: friction(vel)
;; @mut: AF
_fric_min:
	rlca
	ret z
	sbc a :: cpl :: or 1
	ret


; Calculate simple friction (1/16) for the given velocity.
; The result is an acceleration (with magnitude in the range `[1..abs(vel)]`) opposed to the direction (sign) of the input velocity, or zero if the velocity is zero.
; @param A: vel
; @ret A: friction(vel)
; @mut: AF
_fric_1_16:
	and a :: ret z
	cp $80
	jr nc, .negative
	; positive: divide first
	swap a :: and $0E
	cpl; :: inc a
	;dec a
	ret
.negative
	; negative: invert first
	cpl :: inc a
	swap a :: and $0E
	inc a
	ret

_fric_1_32:
	and a :: ret z
	cp $80
	jr nc, .negative
	; positive: divide first
	rlca :: rlca :: rlca :: and $06
	cpl; :: inc a
	;dec a
	ret
.negative
	; negative: invert first
	cpl :: inc a
	rlca :: rlca :: rlca :: and $06
	inc a
	ret

_fric_1_8:
	and a :: ret z
	cp $80
	jr nc, .negative
	; positive: divide first
	rrca :: rrca :: rrca :: and $1E
	cpl; :: inc a
	;dec a
	ret
.negative
	; negative: invert first
	cpl :: inc a
	rrca :: rrca :: rrca :: and $1E
	inc a
	ret

_fric_1_4:
	and a :: ret z
	cp $80
	jr nc, .negative
	; positive: divide first
	rrca :: rrca :: and $3E
	cpl; :: inc a
	;dec a
	ret
.negative
	; negative: invert first
	cpl :: inc a
	rrca :: rrca :: and $3E
	inc a
	ret

_fric_1_2:
	and a :: ret z
	cp $80
	jr nc, .negative
	; positive: divide first
	rrca :: and $7E
	cpl; :: inc a
	;dec a
	ret
.negative
	; negative: invert first
	cpl :: inc a
	rrca :: and $7E
	inc a
	ret

