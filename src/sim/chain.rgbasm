include "hardware.inc"
include "banker.rgbinc"
include "chain.rgbinc"


pushs "ChainInit", rom0
;; @param HL: ChainDef
;; @mut: AF, BC, DE, HL
ChainInit::
	; ChainDef
	ld a, [hl+] :: ld c, a ; capacity
	ld a, [hl+] :: ld b, a ; linkspan
		wrambopen [hl+]    ; state_bank
	ld a, [hl+]            ; state_addr.0
	ld h, [hl]             ; state_addr.1
	ld l, a

;; @param HL: this ChainState
;; @param C: length
;; @param B: linkspan
;; @mut: AF, C, DE, HL
ChainInit_direct::
	; ChainState
	ld a, 222 :: ld [hl+], a ; origin_y.0
	xor a :: ld [hl+], a ; origin_y.1
	ld a, 111 :: ld [hl+], a ; origin_x.0
	xor a :: ld [hl+], a ; origin_x.1
	ld a, c :: ld [hl+], a ; length
		push hl
	; DE = link_x
	ld e, c :: ld d, 0
	add hl, de
	ld e, l :: ld d, h
		pop hl
	xor a
:
	ld [hl+], a ; y
	ld [de], a :: inc de ; x
	add b
	dec c
	jr nz, :-

	ret

pops ; ChainInit


pushs "ChainUpdate", rom0
;; @param HL: ChainDef
ChainUpdate::
	; ChainDef
	rept ChainDef_linkspan
		inc hl
	endr
	ld a, [hl+] :: ld e, a ; linkspan
		wrambopen [hl+]    ; state_bank
	ld a, [hl+]            ; state_addr.0
	ld h, [hl]             ; state_addr.1
	ld l, a

;; @param HL: this ChainState
;; @param E: linkspan
ChainUpdate_direct::
	; ChainState
	rept ChainCtl_length
		inc hl
	endr
		push hl ; length
	ld a, [hl+] :: ld c, a ; length

	ld b, 0 ; BC = length
	add hl, bc ; HL = link_y[N]
	add hl, bc ; HL = link_x[N]

	/*
		Drag chain from endpoint:
		- iterate neighbouring pairs from back to front
		- move each link[i] to stay within linkspan of link[i + 1]
		- each axis handled independently

			d = p[i+1] - p[i]
			over = max(0, abs(d) - link_distance_max) * sign(d)
			p[i] += over
	*/
	ld b, 2 ; outer loop ({x, y})
	dec c :: dec c ; iters = N - 2 in order to stop before anchor point.
.drag_bloop:
		push bc
	dec hl ; from end of array (N) to last element (N-1).
.drag_cloop:
	ld a, [hl-] ; p[i+1]
	sub [hl] :: ld d, a ; d = p1 - p0
	; over = abs(d) - linkspan
	call AbsS8
	sub e
	; if F.C: over <= 0 ~~ no drag
	jr c, .in_range
	bit 7, d
	jr z, :+
	cpl :: inc a ; -over
:
	; p0' = p0 + over * sign(d)
	add [hl] :: ld [hl], a
.in_range:
	dec c
	jr nz, .drag_cloop
		pop bc
	; HL will be pointing at i=1 ~~~ dec to get to i=0 (link_y[N])
	dec hl
	dec b
	jr nz, .drag_bloop

		pop hl ; length
	ld a, [hl+] :: ld c, a ; length

	/*
		Apply constraints

		Limit link spacing to linkspan
		- iterate neighbouring pairs forwards
		- limit p[i] to p[i-1] + linkspan

			d = p[i] - p[i-1]
			p[i] += p[i-1] + min(|d|, linkspan) * sign(d)
	*/
	ld b, 2 ; outer loop ({x, y})
	; Operating on connected pairs (i, i+1) so do N-1 iters
	dec c
.constrain_bloop:
		push bc
.constrain_cloop:
	ld a, [hl+] :: ld b, a ; B = p[i-1]
	ld a, [hl] :: sub b :: ld d, a ; d = p[i] - p[i-1]
	call AbsS8
	cp e
	jr c, .constrain_in_range
	; |d| >= linkspan
	ld a, e ; clamped = linkspan
	bit 7, d
	jr z, :+
	cpl :: inc a ; -clamped
:
	add b ; p[i-1] + clamped
	ld [hl], a
.constrain_in_range:
	dec c
	jr nz, .constrain_cloop
		pop bc
	inc hl ; from link_y[N-1] to link_x[0]
	dec b
	jr nz, .constrain_bloop

	ret

pops ; ChainUpdate


pushs "wChainRender", wram0
wChainRender:
	.count: db

pops ; wChainRender


pushs "ChainRender", rom0
;; @param HL: ChainDef
;; @param hObMod*: Obx params
ChainRender::
	; ChainDef
	rept ChainDef_state_bank
		inc hl
	endr
		wrambopen [hl+]    ; state_bank
	ld a, [hl+]            ; state_addr.0
	ld h, [hl]             ; state_addr.1
	ld l, a

;; @param HL: this ChainState
;; @param hObMod*: Obx params
ChainRender_direct::
	; ChainState
	rept ChainCtl_origin_y
		inc hl
	endr
	; Check visibility & get screen position for rendering.
	call ChainOriginOnScreen
	ret nc ; not visible
	; Origin screen position will be applied from hObMod{Y,X}.
	ldh a, [hObModY] :: add b :: ldh [hObModY], a
	ldh a, [hObModX] :: add c :: ldh [hObModX], a

	; Get chain length & calculate link_x address
	ld a, [hl+] :: ld c, a ; length
	ld b, 0 ; BC = length
		push hl
	add hl, bc :: add hl, bc :: dec hl
	ld e, l :: ld d, h ; DE = link_x[-1]
		pop hl

	dec c ; skip link 0
	ld b, c
.stack_x_loop:
	ld a, [de] :: dec de
		push af ; X
	dec c
	jr nz, .stack_x_loop

	ld a, $FF :: ld [wChainRender.count], a

	ld c, b
	ld e, l :: ld d, h
	inc de ; skip link 0
	call ObdoCustomStartHL
.cloop:
	; Y
	ldh a, [hObModY] :: ld b, a
	ld a, [de] :: inc de
	add b :: ld [hl+], a
	; X
	ldh a, [hObModX] :: ld b, a
		pop af
	add b :: ld [hl+], a
	; CHRI
	ld b, 3 ; endpoint chri
	ld a, c
	dec a
	; at last link if C == 1
	jr z, .chri_set
	ld a, [wChainRender.count]
	inc a
	ld [wChainRender.count], a
	; ld b, a ; will be 0 if at first link
	; ; count starts at -1
	; jr z, .chri_set
	; in the middle ... alternate between chri +1, +2
	and $01
	inc a
	ld b, a
.chri_set:
	ldh a, [hObModChri]
	add b
	ld [hl+], a

	; ATRB
	ldh a, [hObModAtrb]
	ld [hl+], a
	dec c
	jr nz, .cloop

	jp ObdoCustomEndHL


;; Get position of chain origin in screen dots & do Sprx potentially visible test.
;; @param HL: pointer to Chain origin position (16 bit Dots) `{origin_y: dw, origin_x: dw}`
;; @ret HL: pointer at end of origin position (value provided in HL + 4)
;; @ret B,C: Y,X
;; @ret F.C: set if (potentially) visible
;; @mut: AF, BC, DE, HL
ChainOriginOnScreen:
	ld a, [wScroll.y + 0] :: ld e, a
	ld a, [wScroll.y + 1] :: ld d, a
	; load item position and subtract scroll position
	ld a, [hl+] :: sub e :: ld c, a
	ld a, [hl+] :: sbc d :: ld b, a

		push bc
	ld a, [wScroll.x + 0] :: ld c, a
	ld a, [wScroll.x + 1] :: ld b, a
	ld a, [hl+] :: sub c :: ld e, a
	ld a, [hl+] :: sbc b :: ld d, a
		pop bc

	jp SprxTestVisibility

pops ; ChainRender


pushs "ChainSetEnd", rom0
;; @param HL: ChainDef
;; @param D,E: Y,X position
ChainSetEnd::
	; ChainDef
	rept ChainDef_state_bank
		inc hl
	endr
		wrambopen [hl+]    ; state_bank
	ld a, [hl+]            ; state_addr.0
	ld h, [hl]             ; state_addr.1
	ld l, a

;; @param HL: this ChainState
;; @param D,E: Y,X position
ChainSetEnd_direct::
	; ChainState
	rept ChainCtl_length
		inc hl
	endr
	ld a, [hl+] :: dec a ; length - 1
	ld c, a :: ld b, 0 ; BC = length - 1
	add hl, bc ; HL = link_y + length - 1
	ld a, d :: ld [hl+], a ; Y
	add hl, bc ; HL = link_y + length * 2 - 1 = link_x + length - 1
	ld a, e :: ld [hl+], a ; X

	ret

pops ; ChainSetEnd


pushs "ChainSetOrigin", rom0
;; Set the chain's origin position. Link positions are relative to this.
;; @param HL: this ChainDef
;; @param DE: X position in dots
;; @param BC: Y position in dots
ChainSetOrigin::
	; ChainDef
	rept ChainDef_state_bank
		inc hl
	endr
		wrambopen [hl+]    ; state_bank
	ld a, [hl+]            ; state_addr.0
	ld h, [hl]             ; state_addr.1
	ld l, a

;; @param HL: this ChainState
;; @param DE: X position in dots
;; @param BC: Y position in dots
ChainSetOrigin_direct::
	; ChainState
	rept ChainCtl_origin_y
		inc hl
	endr
	ld a, c :: ld [hl+], a
	ld a, b :: ld [hl+], a
	ld a, e :: ld [hl+], a
	ld a, d :: ld [hl+], a

	ret

pops ; ChainSetOrigin

