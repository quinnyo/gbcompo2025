include "hardware.inc"
include "stuff.rgbinc"
include "coord.rgbinc"
include "banker.rgbinc"


def PLATFORM_CGB   equ $02 ; host is CGB
def PLATFORM_SGB   equ $04 ; host is SGB
def PLATFORM_COLOR equ $08 ; CGB mode
def PLATFORM_REV   equ $10 ; CGB=AGB, SGB=SGB2, 0=MGB


section "wPlatform", wram0
wPlatform::
	.flags:: db


section "LCD Interrupt", rom0[$48]
	reti


section "Timer Interrupt", rom0[$50]
	reti


section "Serial Interrupt", rom0[$58]
	reti


section "Joypad Interrupt", rom0[$60]
	reti


section "Header", rom0[$100]
	nop
	jp Boot

	ds $150 - @, 0


section "assets/fonty8.chr", romx
incbin "assets/fonty8.chr"


section "assets/iconoglyphs.chr", romx
incbin "assets/iconoglyphs.chr", 0, 16 * 8


section "Main", rom0
Boot:
	; A = 11(CGB,AGB)
	cp $11
	jr z, .detect_color
	; A = FF(MGB,SGB2), 01(DMG,SGB)
	and PLATFORM_REV
	; C = 13(DMG,MGB), 14(SGBx)
	or PLATFORM_SGB
	and c
	jr .detect_finalise
.detect_color:
	; D = 00(DMG Mode), FF(CGB Mode)
	ld a, PLATFORM_COLOR
	and d
	or PLATFORM_CGB
	; B = 00(CGB), 01(AGB)
	swap b
	or b
	jr .detect_finalise
.detect_finalise
	ld [wPlatform.flags], a

Main::
	ld sp, $FFFE

	di

	xor a
	ldh [rNR52], a

	vblank_wait
	xor a
	ldh [rLCDC], a

	call RombInit
	call WrambInit

	rombpush bank("assets/fonty8.chr")
	ld de, startof("assets/fonty8.chr")
	ld bc, sizeof("assets/fonty8.chr")
	ld hl, $9000
	call MemCopyLarge
	rombpop

	rombpush bank("assets/iconoglyphs.chr")
	ld de, startof("assets/iconoglyphs.chr")
	ld bc, sizeof("assets/iconoglyphs.chr")
	ld hl, $8000
	call MemCopyLarge
	rombpop

	call VBlankInit
	call InputInit
	call PalettesInit
	call VramxInit
	call ScrollInit
	call PlayerInit
;	call MainInit
	call EntityInit
	call CollideInit
	call MockMapConnect
	call ScrollRenderVisible

	ldh a, [rLCDC]
	or LCDCF_ON | LCDCF_BGON | LCDCF_OBJ16 | LCDCF_OBJON
	ldh [rLCDC], a

	; Default palette (DMG)
	ld a, %11_10_01_00
	ldh [rBGP], a
	ldh [rOBP0], a
	ldh [rOBP1], a

	xor a
	ldh [rIF], a
	ei
.loop:
	call InputRead
	call InputUpdate
	call VramxSync
	call PlayerUpdate

/*
	; debugfly: override player input
	ld a, [wInput.state]
	ld b, a
	xor a
	bit PADB_UP, b
	jr z, :+
	dec a
:
	bit PADB_DOWN, b
	jr z, :+
	inc a
:
	add a :: add a :: add a
	ld [wEntity + 6], a
	xor a
	bit PADB_LEFT, b
	jr z, :+
	dec a
:
	bit PADB_RIGHT, b
	jr z, :+
	inc a
:
	add a :: add a :: add a
	ld [wEntity + 2], a
*/

;	call MainUpdate
	call EntityUpdate
	call ScrollUpdate
	ld a, [wScroll.y + 0] :: ld [wSCY], a
	ld a, [wScroll.x + 0] :: ld [wSCX], a

	call _ViewTargetThing

	; dirty test to show entity position
	ld hl, wOAM1
	ld e, 0
	ld a, [wTargetThing.y]
	ld [hl+], a
	ld a, [wTargetThing.x]
	ld [hl+], a
	ld a, e
	ld [hl+], a
	xor a
	ld [hl+], a

.vsync
	ld hl, wVBlankCount
	ld a, [hl]
.vsync_wait
	halt
	nop
	cp [hl]
	jr z, .vsync_wait

	call VramxBeginUpdate

:
	ldh a, [rLY]
	cp 144
	jr nc, :-

	jp .loop



def TARGET_FENCE_TOP equ 48
def TARGET_FENCE_BOTTOM equ 144 - 24
def TARGET_FENCE_LEFT equ 48
def TARGET_FENCE_RIGHT equ 160 - 48
_ViewTargetThing:
	; scroll target position
	ld a, [wScroll.y + 0] :: ld l, a
	ld a, [wScroll.y + 1] :: ld h, a
	ld a, [wEntity + 8 + 0] :: ld c, a
	ld a, [wEntity + 8 + 1] :: ld b, a
	coord_sub bc, WORLD_ORIGIN
	coord_int16 bc
	; screenpos = entitypos - scrollpos
	ld a, c
	sub l
	ld c, a
	ld a, b
	sbc h
	ld b, a
	ld a, c
	jr z, :+
	xor a
:
	ld [wTargetThing.y], a

	coord_sub bc, TARGET_FENCE_TOP
	jr c, .keepy ; keep if negative
	coord_sub bc, TARGET_FENCE_BOTTOM - TARGET_FENCE_TOP
	jr c, :+ ; keep if positive
.keepy
	ld a, c :: ld [wScroll.dy], a
:

	ld a, [wScroll.x + 0] :: ld l, a
	ld a, [wScroll.x + 1] :: ld h, a
	ld a, [wEntity + 4 + 0] :: ld c, a
	ld a, [wEntity + 4 + 1] :: ld b, a
	coord_sub bc, WORLD_ORIGIN
	coord_int16 bc
	; screenpos = entitypos - scrollpos
	ld a, c
	sub l
	ld c, a
	ld a, b
	sbc h
	ld b, a
	ld a, c
	jr z, :+
	xor a
:
	ld [wTargetThing.x], a

	coord_sub bc, TARGET_FENCE_LEFT
	jr c, .keepx
	coord_sub bc, TARGET_FENCE_RIGHT - TARGET_FENCE_LEFT
	jr c, :+
.keepx
	ld a, c :: ld [wScroll.dx], a
:

	ret


section "wTargetThing", wram0
wTargetThing::
	.y:: db
	.x:: db

