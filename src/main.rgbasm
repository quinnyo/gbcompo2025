include "hardware.inc"
include "stuff.rgbinc"
include "coord.rgbinc"


def PLATFORM_CGB   equ $02 ; host is CGB
def PLATFORM_SGB   equ $04 ; host is SGB
def PLATFORM_COLOR equ $08 ; CGB mode
def PLATFORM_REV   equ $10 ; CGB=AGB, SGB=SGB2, 0=MGB


section "wPlatform", wram0
wPlatform::
	.flags:: db


section "LCD Interrupt", rom0[$48]
	reti


section "Timer Interrupt", rom0[$50]
	reti


section "Serial Interrupt", rom0[$58]
	reti


section "Joypad Interrupt", rom0[$60]
	reti


section "Header", rom0[$100]
	nop
	jp Boot

	ds $150 - @, 0


section "assets/fonty8.chr", romx
incbin "assets/fonty8.chr"


section "assets/iconoglyphs.chr", romx
incbin "assets/iconoglyphs.chr", 0, 16 * 8


section "Main", rom0
Boot:
	; A = 11(CGB,AGB)
	cp $11
	jr z, .detect_color
	; A = FF(MGB,SGB2), 01(DMG,SGB)
	and PLATFORM_REV
	; C = 13(DMG,MGB), 14(SGBx)
	or PLATFORM_SGB
	and c
	jr .detect_finalise
.detect_color:
	; D = 00(DMG Mode), FF(CGB Mode)
	ld a, PLATFORM_COLOR
	and d
	or PLATFORM_CGB
	; B = 00(CGB), 01(AGB)
	swap b
	or b
	jr .detect_finalise
.detect_finalise
	ld [wPlatform.flags], a

Main::
	ld sp, $FFFE

	di

	xor a
	ldh [rNR52], a

	vblank_wait
	xor a
	ldh [rLCDC], a

	rombsel bank("assets/fonty8.chr")
	ld de, startof("assets/fonty8.chr")
	ld bc, sizeof("assets/fonty8.chr")
	ld hl, $9000
	call MemCopyLarge

	rombsel bank("assets/iconoglyphs.chr")
	ld de, startof("assets/iconoglyphs.chr")
	ld bc, sizeof("assets/iconoglyphs.chr")
	ld hl, $8000
	call MemCopyLarge

	call VBlankInit
	call InputInit
	call PalettesInit
	call VramxInit
	call ScrollInit
	call PlayerInit
;	call MainInit
	call EntityInit
	call CollideInit
	call MockMapConnect
	call ScrollRenderVisible

	ldh a, [rLCDC]
	or LCDCF_ON | LCDCF_BGON | LCDCF_OBJ16 | LCDCF_OBJON
	ldh [rLCDC], a

	; Default palette (DMG)
	ld a, %11_10_01_00
	ldh [rBGP], a
	ldh [rOBP0], a
	ldh [rOBP1], a

	xor a
	ldh [rIF], a
	ei
.loop:
	call InputRead
	call InputUpdate
	call VramxSync
	call PlayerUpdate
;	call MainUpdate
	call EntityUpdate

	ld a, [wInput.state]
	ld hl, wScroll.dy
	bit PADB_UP, a
	jr z, :+
	dec [hl]
:
	bit PADB_DOWN, a
	jr z, :+
	inc [hl]
:
	ld hl, wScroll.dx
	bit PADB_LEFT, a
	jr z, :+
	dec [hl]
:
	bit PADB_RIGHT, a
	jr z, :+
	inc [hl]
:

	call ScrollUpdate
	ld a, [wScroll.y + 0] :: ld [wSCY], a
	ld a, [wScroll.x + 0] :: ld [wSCX], a

	; dirty test to show entity position
	ld hl, wOAM1
	ld e, 0
	ld a, [wEntity + 8 + 0] :: ld c, a
	ld a, [wEntity + 8 + 1] :: ld b, a
	coord_sub bc, WORLD_ORIGIN
	coord_int8 b, c
	ld [hl+], a
	ld a, [wEntity + 4 + 0] :: ld c, a
	ld a, [wEntity + 4 + 1] :: ld b, a
	coord_sub bc, WORLD_ORIGIN
	coord_int8 b, c
	add 8
	ld [hl+], a
	ld a, e
	ld [hl+], a
	xor a
	ld [hl+], a

.vsync
	ld hl, wVBlankCount
	ld a, [hl]
.vsync_wait
	halt
	nop
	cp [hl]
	jr z, .vsync_wait

	call VramxBeginUpdate

:
	ldh a, [rLY]
	cp 144
	jr nc, :-

	jp .loop

