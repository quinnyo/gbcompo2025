include "hardware.inc"
include "quest.rgbinc"
include "banker.rgbinc"


/*
Quest: progression / collectables / unlocks
*/


pushs "TypInfo", romx
TypInfo::
	;; Number of Typs defined
	.count:: db TYP_COUNT
	;; Number of TypClasses defined
	.class_count:: db TYP_CLASS_COUNT

	;; Member of class
	.class:: db {ALL_TYP_CLASS}
	;; Position in class
	.class_ord:: db {ALL_TYP_CLASS_ORD}

pops ; TypInfo


pushs "TypGetClass", rom0
;; @param E: TypId
;; @ret D: class that TypId belongs to.
;; @ret E: TypId ordinal position in class
;; @ret F.C: set on success
;; @mut: AF, DE
TypGetClass::
	ld a, e
	cp TYP_COUNT
	ret nc

		rombopen bank(TypInfo)
		push hl
	ld d, 0
	ld hl, TypInfo.class
	add hl, de
	ld a, [hl] ; class

	ld hl, TypInfo.class_ord
	add hl, de
	ld d, a ; class
	ld e, [hl] ; ord
		pop hl

	scf
	ret

pops ; TypGetClass


section "wQuest", wramx
;; Finds collection storage, 1 bit per item: got or not.
wFinds: ds FINDS_COUNT >> 3


section "QuestInit", rom0
QuestInit::
	wrambopen bank("wQuest")
	ld hl, startof("wQuest")
	ld c, sizeof("wQuest")
	xor a
	jp MemFillSmall


section "FindIdDecode", rom0
;; Extract components from a FindId.
;; @param A: ID
;; @ret D: store byte (only if success)
;; @ret E: member index (only if success)
;; @ret F.C: success; set if ID in range and valid
;; @mut: AF, DE
FindIdDecode::
	cp FINDS_COUNT
	ret nc

	ld d, a
	and $07
	ld e, a ; member index
	xor d
	rrca :: rrca :: rrca
	ld d, a ; store byte
	scf
	ret


section "FindsAdd", rom0
;; Add a find to the collection.
;; @param A: Find ID
;; @mut: AF, DE, HL
FindsAdd::
	call FindIdDecode
	jr nc, .err_out_of_range

	ld hl, BitmaskTable
	ld a, e :: add l :: ld l, a
	ld e, [hl]

		wrambpush bank(wFinds)
	ld hl, wFinds
	ld a, d :: add l :: ld l, a
	adc h :: sub l :: ld h, a
	ld a, [hl]
	; TODO: something if it was unset ?
	or e
	ld [hl], a
		wrambpop
	ret

.err_out_of_range:
	ld b, b
	ret


section "FindsQuery", rom0
;; Check if a find is in the collection.
;; @param A: Find ID
;; @ret A: Find state (if valid)
;; @ret F.Z: set if find is *not* in the collection.
;; @ret F.C: set if result is valid
;; @mut: AF, DE, HL
FindsQuery::
	call FindIdDecode
	jr nc, .not_found

	ld hl, BitmaskTable
	ld a, e :: add l :: ld l, a
	ld e, [hl]

		wrambpush bank(wFinds)
	ld hl, wFinds
	ld a, d :: add l :: ld l, a
	adc h :: sub l :: ld h, a
	ld a, [hl]
	and e
	ld e, a
		wrambpop
	ld a, e
	and a
	scf
	ret

.not_found:
	xor a ; F.NC, F.Z
	ret
