include "banker.rgbinc"
include "hardware.inc"


section "hMem", hram
hMemSrcBank:: db
hMemParamHL:: dw
hMemStrideGap:: db
hMemScratch: db


section "Mem", rom0
;; Copy up to 256 bytes from one location to another.
;; @param C: length, 0 is interpreted as 256
;; @param DE: source
;; @param HL: destination
;; @mut: AF, C, DE, HL
MemCopySmall::
:
	ld a, [de]
	inc de
	ld [hl+], a
	dec c
	jr nz, :-
	ret


;; Copy up to 65536 bytes from one location to another.
;; (joke about finding 64K to read + 64K to write)
;; @param BC: length, 0 is interpreted as 65536
;; @param DE: source
;; @param HL: destination
;; @mut: AF, BC, DE, HL
MemCopyLarge::
	dec bc
	inc c
	inc b
:
	ld a, [de]
	inc de
	ld [hl+], a
	dec c
	jr nz, :-
	dec b
	jr nz, :-
	ret


;; Fill a block of memory (up to 256 bytes) with a single value.
;; @param A: value
;; @param C: length, 0 is interpreted as 256
;; @param HL: destination
;; @mut: F, C, HL
MemFillSmall::
:
	ld [hl+], a
	dec c
	jr nz, :-
	ret


;; @param A: value
;; @param BC: length, 0 is interpreted as 65536
;; @param HL: destination
;; @mut: AF, BC, HL
MemFillLarge::
	dec bc
	inc c
	inc b
:
	ld [hl+], a
	dec c
	jr nz, :-
	dec b
	jr nz, :-
	ret


;; Fill a region with repeated copies of another.
;; @param DE: source
;; @param B: reps, 0 is interpreted as 256
;; @param C: item size
;; @param HL: region start
;; @mut: AF, BC, DE, HL
MemFillRepeat::
	ld a, c :: ldh [hMemScratch], a
.outer
		push de
.inner
	ld a, [de]
	inc de
	ld [hl+], a
	dec c
	jr nz, .inner
		pop de
	ldh a, [hMemScratch] :: ld c, a
	dec b
	jr nz, .outer
	ret


;; Copy from a contiguous source to another location with spacing applied.
;; After every block, the destination pointer is advanced by the stride gap.
;; No changes are made to the stride gap regions.
;; @param [hMemStrideGap]: stride gap size
;; @param C: block size
;; @param B: block count
;; @param DE: source
;; @param HL: destination
;; @mut: AF, BC, DE, HL
MemCopyBlocks::
.bloop
	; copy block
	push bc ; stash block size
:
	ld a, [de] :: inc de
	ld [hl+], a
	dec c
	jr nz, :-

	; skip stride gap
	ldh a, [hMemStrideGap]
	add l :: ld l, a
	adc h :: sub l :: ld h, a

	pop bc ; restore block size

	dec b
	jr nz, .bloop
	ret


;; Copy from contiguous submap (tilemap with columns < 32) to 32 column bgmap buffer.
;; @param C: submap columns
;; @param B: submap rows
;; @param DE: source
;; @param HL: destination
MemCopySubBgMap::
	ld a, 32
	sub c
	jr c, .err_submap_oversize
	ldh [hMemStrideGap], a
	jr MemCopyBlocks
.err_submap_oversize:
	ld b, b
	jr .err_submap_oversize


;; Do banking before calling another function.
;; @param [hMemParamHL]: target function param HL
;; @param [hMemSrcBank]: source data bank
;; @param HL: target function
MemCallRomx::
	rombopen
	ldh a, [hMemSrcBank]
	ld [ROMB_LO], a

	push hl
	ldh a, [hMemParamHL + 0] :: ld l, a
	ldh a, [hMemParamHL + 1] :: ld h, a
	ret ; return to HL


;; Write a single value to every cell in a subrect of a BG map in VRAM.
;; This routine will block until the operation is complete. As this
;; involves waiting for VBlank in order to access VRAM safely, large
;; operations may occur over multiple frames.
;; @param HL: origin address
;; @param D: value
;; @param B: subrect width (columns)
;; @param C: subrect height (rows)
;; @mut: AF, C, DE, HL
FillBGRect::
	di
.cloop:
	ldh a, [rLY]
	cp 144
	jr c, .cloop
	cp 152
	jr nc, .cloop

	ld e, b
	ld a, d
:
	ld [hl+], a
	dec e
	jr nz, :-
	ld a, 32 :: sub b
	add l :: ld l, a
	adc h :: sub l :: ld h, a
	dec c
	jr nz, .cloop
	reti

