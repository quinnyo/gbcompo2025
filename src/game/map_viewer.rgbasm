include "hardware.inc"
include "banker.rgbinc"


;; Required keys held to enable other inputs
def KEYF_GATE equ PADF_SELECT
;; Clear the wMapBg buffers
def KEYB_CLEAR equ PADB_START
;; Change motion mode (smooth, grid steps)
def KEYB_MOTION_MODE equ PADB_RIGHT


rsreset
def MOTION_STEP rb 1
def MOTION_SMOOTH rb 1
def MOTION__COUNT rb 0


rsreset
def Motion_mode rb 1
def Motion_params rb 1
def Motion_state rb 2
def szMotion rb 0


section "wMapViewer", wramx
;; Motion controller state
wMapViewerMotion: ds szMotion


section fragment "modeGame", romx
MapViewerInit::
	wrambopen bank("wMapViewer")
	ld hl, wMapViewerMotion
	ld a, MOTION_SMOOTH
	call _MotionSetMode
	ret


MapViewerUpdate::
	wrambopen bank("wMapViewer")
	ldh a, [hKeys]
	cpl :: and KEYF_GATE ; F.Z = (KEYS & GATE) == GATE
	call z, _GatedInput

	ld hl, wMapViewerMotion
	call _Motion
	ld a, d :: ld [wScroll.dy], a
	ld a, e :: ld [wScroll.dx], a
	ret


_GatedInput:
	ldh a, [hKeysPressed]
	bit KEYB_CLEAR, a
	jp nz, _Clear

	ld hl, wMapViewerMotion
	bit KEYB_MOTION_MODE, a
	jp nz, _MotionModeNext
	ret


_Clear:
	ld hl, wMapBgChr
	ld bc, 1024
	ld a, 95
	call MemFillLarge
	wrambopen bank(wMapBgAtrb)
	ld hl, wMapBgAtrb
	ld bc, 1024
	ld a, $08
	jp MemFillLarge


_motionSmoothSpeeds:
	db 7, 5
	db 10, 7
	db 17, 12
def _NSPEEDS equ (@ - _motionSmoothSpeeds) / 2
def MOTION_SMOOTH_SPEED_DEFAULT equ 1


;; @param B: acceleration
;; @param C: velocity
;; @ret A: velocity
;; @mut: AF, BC, D
_motionSmoothAccelerate:
	; if accel == 0, do drag only
	ld a, b
	and a
	jr z, .drag

	; if v0 == 0, just take accel as v1
	ld a, c
	and a
	jr z, .use_v1

	; forwardaccel: set if accel in same direction as velocity
	ld a, b
	xor c :: cpl :: ld d, a 

	; if accel opposes velocity, accel more
	bit 7, d
	jr nz, :+
	sla b
:

	; v1 = v0 + accel
	ld a, c :: add b :: ld b, a

	; vflip: set if sign(v1) != sign(v0)
	xor c
	; if forwardaccel AND vflip: overflowed
	and d :: rlca
	jr nc, .use_v1
	; overflowed, take max speed with sign of accel & v0
.clampMax:
	ld a, $7F ; maxSpeed
	bit 7, c
	jr z, .positive
	ld a, $81 ; -maxSpeed
	jr .negative

.use_v1:
	ld c, b
.drag:
	ld a, c
	cp $80
	jr c, .positive
.negative:
	cpl :: inc a
	call .positive
	cpl :: inc a
	ret
.positive:
	; limit max speed
	cp $80
	jr c, :+
	ld a, $7F
:

	dec a
	ld b, a
	sra b :: sra b :: sra b :: sra b
	sub b
	ret


;; @param A: velocity
;; @ret A: scaled scroll delta
_motionSmoothScrollDelta:
	and a :: ret z
	cp $80
	jr c, .positive
.negative:
	or $0F :: swap a
	ret
.positive:
	; scale -velocity for consistent value range between +/-
	cpl :: inc a
	or $0F :: swap a
	cpl :: inc a
	ret


_err_mode_out_of_range:
	ld b, b
	jr _err_mode_out_of_range
	ret


;; @param HL: this Motion state
;; @ret D,E: Y,X scroll delta
;; @mut: AF, BC, DE, HL
_Motion:
	ld de, 0 ; scroll delta is zero by default
	ld a, [hl+]
	cp MOTION__COUNT
	jr nc, _err_mode_out_of_range
	push hl
	rst RST_SwitchJump
	dw .step
	dw .smooth


;; @ret D,E: Y,X scroll delta
;; @mut: AF, B, DE, HL
.step:
	pop hl

	ld a, [hl+] :: ld e, a ; step size
	ld d, e
	ldh a, [hKeysPressed] :: ld b, a
	jp Vecdir8FromKeys


;; @ret D,E: Y,X scroll delta
;; @mut: AF, BC, DE, HL
.smooth:
	pop hl

	ld a, [hl+] ; speed setting
	cp _NSPEEDS
	jr c, :+
	xor a
:
	add a ; double index to get offset
	ld de, _motionSmoothSpeeds
	add e :: ld e, a
	adc d :: sub e :: ld d, a
	ld a, [de] :: inc de ; axial
	ld b, a ; temp
	ld a, [de] ; diag
	ld d, a :: ld e, b
	ldh a, [hKeys] :: ld b, a
	call Vecdir8FromKeys

	; direction input accelY
	ld b, d
	ld c, [hl] ; velY
	call _motionSmoothAccelerate
	ld [hl+], a

	; direction input accelX
	ld b, e
	ld c, [hl] ; velX
	call _motionSmoothAccelerate
	ld [hl-], a ; need HL - 1 to get velY again

	call _motionSmoothScrollDelta
	ld e, a ; scroll delta X

	ld a, [hl] ; velY
	call _motionSmoothScrollDelta
	ld d, a ; scroll delta Y

	ret


;; @param HL: this Motion state
_MotionModeNext:
	ld a, [hl]
	inc a
	cp MOTION__COUNT
	jr c, _MotionSetMode
	xor a

	; FALLTHROUGH

;; @param A: mode
;; @param HL: this Motion state
_MotionSetMode:
	cp MOTION__COUNT
	jr nc, _err_mode_out_of_range
	ld [hl+], a
	push hl
	rst RST_SwitchJump
	dw .step
	dw .smooth


.step:
	pop hl
	ld a, 8 ; step size
	ld [hl+], a
	xor a
	ld [hl+], a
	ld [hl+], a
	ret


.smooth:
	pop hl
	; default speed
	ld a, MOTION_SMOOTH_SPEED_DEFAULT
	ld [hl+], a
	; zero velocity
	xor a
	ld [hl+], a
	ld [hl+], a
	ret

