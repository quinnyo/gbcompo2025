include "hardware.inc"


section "wVBlank", wram0
wLCDC:: db
wSCY:: db
wSCX:: db
wWY:: db
wWX:: db
wVBlankCount:: db


section "hVBlank", hram
;; High byte address of OAM buffer acting as OAM DMA source.
;; Set to zero to skip VBlank OAM sync.
hVBlankObuf:: db


section "VBlankInterrupt", rom0[$40]
	push af
	push hl
	jr VBlankHandler


; The address of the VBlank interrupt handler is set manually to ensure it's in `jr` range of the VBlank interrupt.
; `$68` allows 8 bytes for the input interrupt, the interrupt vector with the highest address.
section "VBlankHandler", rom0[$68]
VBlankHandler::
	ld hl, wLCDC
	ld a, [hl+] :: ldh [rLCDC], a
	ld a, [hl+] :: ldh [rSCY], a
	ld a, [hl+] :: ldh [rSCX], a
	ld a, [hl+] :: ldh [rWY], a
	ld a, [hl+] :: ldh [rWX], a
	inc [hl]

	; OAM DMA transfer
	ldh a, [hVBlankObuf]
	and a
	call nz, hObufLoadDMA

	pop hl
	pop af
	reti


assert @ <= $100, "VBlankHandler is too long"


section "VBlank Impl", rom0
VBlankInit::
	xor a
	ldh [hVBlankObuf], a
	ld hl, wLCDC
	ldh a, [rLCDC]
	ld [hl+], a ; LCDC
	xor a
	ld [hl+], a ; SCY
	ld [hl+], a ; SCX
	cpl a ; $FF
	ld [hl+], a ; WY
	ld [hl+], a ; WX
	xor a
	ld [hl+], a ; wVBlankCount

	ld hl, rIE
	set IEB_VBLANK, [hl]

	; Load OAM DMA transfer code
	ld hl, startof("hObufLoadDMA")
	ld de, startof("rObufLoadDMA")
	ld c, sizeof("rObufLoadDMA")
:
	ld a, [de]
	inc de
	ld [hl+], a
	dec c
	jr nz, :-
	ret


pushs "rObufLoadDMA", rom0
load union "hObufLoadDMA", hram
; Copy buffer to OAM using DMA.
; @param A: High byte address of source buffer.
hObufLoadDMA:
	ldh [rDMA], a
	ld a, OAM_COUNT
:
	dec a
	jr nz, :-
	ret

endl
pops


section "DisplayEnable", rom0
DisplayEnable::
	ld a, [wLCDC]
	or LCDCF_ON
	ld [wLCDC], a
	ldh [rLCDC], a
	ret

