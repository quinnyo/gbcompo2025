include "banker.rgbinc"
include "stuff.rgbinc"


/*** ROM Bank numbers ***/
for I, ROMB_COUNT
	def __SECTION_NAME equs "RomBankId{d:I}"
if I == 0
	section "{__SECTION_NAME}", rom0[RomBankId - $4000]
else
	section "{__SECTION_NAME}", romx[RomBankId], bank[I]
endc
	{__SECTION_NAME}:: db I

	purge __SECTION_NAME
endr


def STACK_ALIGN_BITS equ bitwidth(BANKER_STACK_SIZE + 1) - 1


section "wBankerWramb", wram0
wWramb:
wBankerWramb:: align STACK_ALIGN_BITS
	.sp: db
	.stack: ds BANKER_STACK_SIZE


section "wBankerRomb", wram0
wRomb:
wBankerRomb:: align STACK_ALIGN_BITS
	.sp: db
	.stack: ds BANKER_STACK_SIZE


section "Banker", rom0
BankerInit::
	ld a, 1 :: ld [ROMB_LO], a
	ld hl, wRomb
	call _BankerStackInit

	ld a, 1 :: ldh [rSVBK], a
	ld hl, wWramb
	jp _BankerStackInit


;; @param HL: &stack
_BankerStackInit:
	ld c, BANKER_STACK_SIZE
	ld a, c :: inc a :: ld [hl+], a
	ld a, $FF
:
	ld [hl+], a
	dec c
	jr nz, :-
	ret


/*
section "BankerRombPush", rom0
;; @param B: Destination ROMX bank
;; @mut: AF, HL
BankerRombPush::
	ld hl, wBankerRomb

	; bounds check
	ld a, [hl]
	and a
	jr z, .err_stack_overflow

	; stash current bank
	dec [hl]
	ld l, [hl]
	ld a, [RomBankId]
	ld [hl], a

	; switch bank
	ld a, b
	ld [ROMB_LO], a
	ret
.err_stack_overflow:
	ld b, b
	jr .err_stack_overflow


section "BankerRombPop", rom0
;; @mut: AF, HL
BankerRombPop::
	ld hl, wBankerRomb
	ld a, [hl]

	cp low(wBankerRomb.stack) + BANKER_STACK_SIZE
	jr nc, .err_stack_empty

	inc [hl]
	ld l, a

	; restore bank
	ld a, [hl]
	ld [ROMB_LO], a
	ret
.err_stack_empty:
	ld b, b
	jr .err_stack_empty
*/

