include "hardware.inc"

/*
# WTF
- move the view by setting deltas: wScroll.dy, wScroll.dx before calling ScrollUpdate
- ScrollUpdate applies the deltas and invokes map rendering
- the `SCY`/`SCX` registers are *NOT* modified
	- probably use `wScroll.y` & `wScroll.x` for this (scroll position in dots, low byte)

# Coordinate Conventions
- scrolling in world space dots
- rendering in world space grid
- convert world to bg space:
	- grid: `bg = world mod 32` or `bg = world & $1F`
	- dot: `bg = world mod 256` or `bg = world & $FF`

# Scroll Scrawl
As scroll scrolls, visible part of map changes.
The map renderer guy has to render stuff before we scroll it into view. (Who knew!)

# Front Forward
The *front* is the line of tiles just outside the view, in the direction of scrolling.
Two fronts are tracked -- one for each axis.
The front is intended to be used as a 'loading seam'.
When scrolling results in the position of a front changing, a ScrollStat flag will be set (until the next update).
*/

rsreset
;; Set to request 'Reset' status.
export def bScrollStat_RequestReset rb 1
;; Set if scroll position has been (re)set directly.
;; i.e. the current view rect has no relation to the previous one.
export def bScrollStat_Reset rb 1
;; Set if hScrollFrontY was changed in the most recent update.
export def bScrollStat_ChangeFrontY rb 1
;; Set if hScrollFrontX was changed in the most recent update.
export def bScrollStat_ChangeFrontX rb 1

export def ScrollStat_RequestReset equ 1 << bScrollStat_RequestReset
export def ScrollStat_Reset equ 1 << bScrollStat_Reset
export def ScrollStat_ChangeFrontY equ 1 << bScrollStat_ChangeFrontY
export def ScrollStat_ChangeFrontX equ 1 << bScrollStat_ChangeFrontX

;; Mask off all transient (set every frame) status flags.
def ScrollStat_Transient equ ScrollStat_Reset | ScrollStat_ChangeFrontY | ScrollStat_ChangeFrontX


def VIEW_COLUMNS equ 20
def VIEW_ROWS equ 18


section "hScroll", hram
hScrollStat:: db
hScrollFrontY:: db
hScrollFrontX:: db
hScrollAppliedY:: db
hScrollAppliedX:: db


section "wScroll", wram0
wScroll::
	;; Pending view position delta (Y axis)
	.dy:: db
	;; View scroll position in dots (Y axis)
	.y:: dw
	;; View scroll grid row
	.row:: dw
	.y_front_dist: db

	;; Pending view position delta (X axis)
	.dx:: db
	;; View scroll position in dots (X axis)
	.x:: dw
	;; View scroll grid column
	.column:: dw
	.x_front_dist: db


section "Scroll", rom0
ScrollInit::
	ld hl, startof("wScroll")
	ld c, sizeof("wScroll")
	xor a
	call MemFillSmall
	ld a, ScrollStat_RequestReset :: ldh [hScrollStat], a
	xor a
	ldh [hScrollFrontY], a
	ldh [hScrollFrontX], a
	ldh [hScrollAppliedY], a
	ldh [hScrollAppliedX], a
	ld a, VIEW_ROWS + 1
	ld [wScroll.y_front_dist], a
	ld a, VIEW_COLUMNS + 1
	ld [wScroll.x_front_dist], a
	ret


;; @ret DE: Tile grid row containing the top edge of the view rect.
;; @mut: AF, DE
ScrollGetViewRow::
	ld a, [wScroll.y + 1] :: ld d, a
	ld a, [wScroll.y + 0]
	; dots / 8
	srl d :: rra
	srl d :: rra
	srl d :: rra
	ld e, a
	ret


;; @ret DE: Tile grid column containing the left edge of the view rect.
;; @mut: AF, DE
ScrollGetViewColumn::
	ld a, [wScroll.x + 1] :: ld d, a
	ld a, [wScroll.x + 0]
	; dots / 8
	srl d :: rra
	srl d :: rra
	srl d :: rra
	ld e, a
	ret


;; @mut: AF, BC, DE, HL
ScrollUpdate::
	ldh a, [hScrollStat]
	and ~(ScrollStat_Transient)
	ld b, a ; B will be the new value for hScrollStat

	ld hl, wScroll.dy
	call .UpdateAxis
	ld a, c :: ldh [hScrollAppliedY], a
	jr nc, :+
	; Store updated front & set changed flag if it actually changed.
	ldh a, [hScrollFrontY]
	cp d
	jr z, :+
	ld a, d :: ldh [hScrollFrontY], a
	set bScrollStat_ChangeFrontY, b
:

	ld hl, wScroll.dx
	call .UpdateAxis
	ld a, c :: ldh [hScrollAppliedX], a
	jr nc, :+
	; Store updated front & set changed flag if it actually changed.
	ldh a, [hScrollFrontX]
	cp d
	jr z, :+
	ld a, d :: ldh [hScrollFrontX], a
	set bScrollStat_ChangeFrontX, b
:

	; Update status
	ld a, b
	and ScrollStat_RequestReset
	jr nz, .set_reset
	ld a, b
.store_stat
	ldh [hScrollStat], a
	ret
.set_reset
	xor b ; clear request flag
	or ScrollStat_Reset
	jr .store_stat


;; @param HL: pointer to scroll axis state
;; @ret D: new front position (only valid with F.C)
;; @ret C: effective delta
;; @ret F.C: set to indicate success
;; @ret F.Z: set if zero delta
;; @mut: AF, C, DE, HL
.UpdateAxis:
	; Load delta & clear the accumulator
	ld c, [hl]
	xor a :: ld [hl+], a
	or c :: ret z ; delta is zero, nothing to do.

	; Apply delta
	ld a, [hl+] :: ld e, a
	ld a, [hl-] :: ld d, a

	; clamp delta if pos < 256
	and a
	jr nz, :+
	; if delta < 0
	bit 7, c
	jr z, :+
	xor a :: sub c
	cp e
	jr c, :+
	; clamp delta to -position
	xor a :: sub e :: ld c, a
	ret z ; effective delta is zero, nothing to do
	ld e, 0
	jr .delta_applied
:

	inc d ; work on pos.hi + 1 to handle underflow
	; signed addition ~~ if delta < 0, dec D to emulate delta having high byte of $FF
	ld a, c
	rlca
	jr nc, :+
	dec d
:
	ld a, e
	add c
	ld e, a
	adc d
	sub e
	ld d, a
	; if D (pos.hi + 1) is zero, it underflowed. Clamp to zero.
	and a
	jr nz, :+
	ld de, $0100
:
	dec d ; undo the inc from before applying the delta, D = pos.hi
.delta_applied

	ld a, e :: ld [hl+], a
	ld a, d :: ld [hl+], a

	; dot to grid
	ld a, e
	srl d :: rra
	srl d :: rra
	srl d :: rra
	ld e, a

	; store grid position
	ld a, e :: ld [hl+], a
	ld a, d :: ld [hl+], a

	; Advance front
	; add -1 if delta is negative or +FRONT offset if positive
	ld a, c :: rlca :: sbc a
	or [hl] ; front_dist
	add e
	ld d, a
	scf ; F.C for success
	ret

