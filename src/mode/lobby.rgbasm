include "hardware.inc"
include "mode.rgbinc"
include "banker.rgbinc"
include "chrimp.rgbinc"


	mode_def modeLobby, modeLobby_ExtraFuncs


	import_screen "assets/screen_Lobby.chr", screen_Lobby


section "modeLobby", romx
modeLobby_ExtraFuncs::
	dw _wait0
	dw _waitCurtain

_wait0:
	call ModeLoadWaitVx :: ret nc

	; Open the curtain
	jp CurtainOpen

_waitCurtain:
	ldh a, [hCurtain]
	and Curtain_STATE
	cp Curtain_OPEN
	ret nz

	ld a, MODE_STATE_PROCESS :: ldh [hModeState], a
	ret


modeLobby_Enter::
	xor a :: ld [wSCY], a :: ld [wSCX], a

	ld h, bank("assets/screen_Lobby.chr.pal")
	ld de, startof("assets/screen_Lobby.chr.pal")
	ld c, sizeof("assets/screen_Lobby.chr.pal") / 8
	ld b, 0
	call PalettesLoadRomx

	load_chr $9000, $9800, "assets/screen_Lobby.chr"
	if def(CHR_REMAIN)
		load_chr $8800, $9000
		assert !def(CHR_REMAIN), "screen_Lobby has too many tiles. Probably optimise the source image."
	endc

	ld de, startof("assets/screen_Lobby.chr.idx")
	ld a, bank("assets/screen_Lobby.chr.idx")
	ldh [hMemSrcBank], a
	ld bc, (18 << 8) | 20
	ld a, low(wMapBgChr) :: ldh [hMemParamHL + 0], a
	ld a, high(wMapBgChr) :: ldh [hMemParamHL + 1], a
	ld hl, MemCopySubBgMap
	call MemCallRomx

	ld de, startof("assets/screen_Lobby.chr.atrb")
	ld a, bank("assets/screen_Lobby.chr.atrb")
	ldh [hMemSrcBank], a
	ld bc, (18 << 8) | 20
	ld a, low(wMapBgAtrb) :: ldh [hMemParamHL + 0], a
	ld a, high(wMapBgAtrb) :: ldh [hMemParamHL + 1], a
	ld hl, MemCopySubBgMap
	call MemCallRomx

	ld a, MODE_STATE_EXTRA :: ldh [hModeState], a
	ret


modeLobby_Process::
	; Wait for key press to start mode transition.
	ldh a, [hKeysPressed]
	and PADF_DOWN | PADF_A
	jr z, :+
	ld de, rModes_modeGamePrep
	jp CurtainModeTransitionBegin
:

	ret


