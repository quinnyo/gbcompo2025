include "hardware.inc"
include "mode.rgbinc"
include "banker.rgbinc"
include "chrimp.rgbinc"


	mode_def modeLobby, modeLobby_Enter, modeLobby_Process, modeLobby_Exit, modeLobby_Halt, modeLobby_Resume, modeLobby_ExtraFuncs

	import_screen "assets/screen_Lobby.chr", screen_Lobby


section "modeLobby", romx
modeLobby_ExtraFuncs::
rsset MODE_STATE_EXTRA
def _STATE_EXTRA_WAIT0 rb 1
	dw _wait0
def _STATE_EXTRA_WAIT_CURTAIN rb 1
	dw _waitCurtain

_wait0:
	call ModeLoadWaitVx :: ret nc

	; Open the curtain
	jp CurtainOpen

_waitCurtain:
	ldh a, [hCurtain]
	and Curtain_STATE
	cp Curtain_OPEN
	ret nz

	ld a, MODE_STATE_PROCESS :: ldh [hModeState], a
	ret


modeLobby_Enter::
	call ChrmanResetAll
	call PalettePalInit

	xor a :: ld [wSCY], a :: ld [wSCX], a

	ld h, bank("assets/screen_Lobby.chr.pal")
	ld de, startof("assets/screen_Lobby.chr.pal")
	ld c, sizeof("assets/screen_Lobby.chr.pal") / 8
	ld b, 0
	call PalettesLoadRomx

	load_chr $9000, $9800, "assets/screen_Lobby.chr"
	if def(CHR_REMAIN)
		load_chr $8800, $9000
		assert !def(CHR_REMAIN), "screen_Lobby has too many tiles. Probably optimise the source image."
	endc

	assert bank(wMapBgChr) == 0
	ld de, startof("assets/screen_Lobby.chr.idx")
	ld a, bank("assets/screen_Lobby.chr.idx")
	ldh [hMemSrcBank], a
	ld bc, (18 << 8) | 20
	ld a, low(wMapBgChr) :: ldh [hMemParamHL + 0], a
	ld a, high(wMapBgChr) :: ldh [hMemParamHL + 1], a
	ld hl, MemCopySubBgMap
	call MemCallRomx

	wrambpush bank(wMapBgAtrb)
	ld de, startof("assets/screen_Lobby.chr.atrb")
	ld a, bank("assets/screen_Lobby.chr.atrb")
	ldh [hMemSrcBank], a
	ld bc, (18 << 8) | 20
	ld a, low(wMapBgAtrb) :: ldh [hMemParamHL + 0], a
	ld a, high(wMapBgAtrb) :: ldh [hMemParamHL + 1], a
	ld hl, MemCopySubBgMap
	call MemCallRomx
	wrambpop

	ld b, bank(musMarchOfTides)
	ld hl, musMarchOfTides
	call MusStart

	xor a
	call audio_play_fx


	ld a, MODE_STATE_EXTRA :: ldh [hModeState], a
	ret


modeLobby_Process::
	; Wait for key press to start mode transition.
	ldh a, [hKeysPressed]
	and PADF_DOWN | PADF_A
	jr z, :+
	; TODO: actual map select
	ld de, map_c1
	ld a, bank(map_c1)
	call MapSelect

	; Start transition to the game world
	call ModePush
	ld de, rModes_modeGamePrep
	jp CurtainModeTransitionBegin
:

	ret


modeLobby_Exit:
	ret


modeLobby_Halt:
	ret


modeLobby_Resume:
	jp modeLobby_Enter

