include "hardware.inc"
include "mode.rgbinc"
include "banker.rgbinc"
include "chrimp.rgbinc"


	mode_def modeTitle, modeTitle_ExtraFuncs


	import_screen "assets/screen_Title.chr", screen_Title


section "modeTitle", romx
modeTitle_ExtraFuncs::
rsset MODE_STATE_EXTRA
def _STATE_EXTRA_WAIT0 rb 1
	dw _wait0
def _STATE_EXTRA_WAIT_CURTAIN rb 1
	dw _waitCurtain
def _STATE_EXTRA_EXITING rb 1
	dw _exiting

_wait0:
	call ModeLoadWaitVx :: ret nc

	; Open the curtain
	jp CurtainOpen

_waitCurtain:
	ldh a, [hCurtain]
	and Curtain_STATE
	cp Curtain_OPEN
	ret nz

	ld a, MODE_STATE_PROCESS :: ldh [hModeState], a
	ret

_exiting:
	ret


modeTitle_Enter::
	call CurtainForceClose

	xor a :: ld [wSCY], a :: ld [wSCX], a

	ld h, bank("assets/screen_Title.chr.pal")
	ld de, startof("assets/screen_Title.chr.pal")
	ld c, sizeof("assets/screen_Title.chr.pal") / 8
	ld b, 0
	call PalettesLoadRomx

	load_chr $9000, $9800, "assets/screen_Title.chr"
	if def(CHR_REMAIN)
		load_chr $8800, $9000
		assert !def(CHR_REMAIN), "screen_Title has too many tiles. Probably optimise the source image."
	endc

	assert bank(wMapBgChr) == 0
	ld de, startof("assets/screen_Title.chr.idx")
	ld a, bank("assets/screen_Title.chr.idx")
	ldh [hMemSrcBank], a
	ld bc, (18 << 8) | 20
	ld a, low(wMapBgChr) :: ldh [hMemParamHL + 0], a
	ld a, high(wMapBgChr) :: ldh [hMemParamHL + 1], a
	ld hl, MemCopySubBgMap
	call MemCallRomx

	wrambpush bank(wMapBgAtrb)
	ld de, startof("assets/screen_Title.chr.atrb")
	ld a, bank("assets/screen_Title.chr.atrb")
	ldh [hMemSrcBank], a
	ld bc, (18 << 8) | 20
	ld a, low(wMapBgAtrb) :: ldh [hMemParamHL + 0], a
	ld a, high(wMapBgAtrb) :: ldh [hMemParamHL + 1], a
	ld hl, MemCopySubBgMap
	call MemCallRomx
	wrambpop

	ld a, MODE_STATE_EXTRA :: ldh [hModeState], a
	ret


modeTitle_Process::
	; Wait for key press to start mode transition.
	ldh a, [hKeysPressed]
	and PADF_START | PADF_A
	jr z, :+

	ld a, _STATE_EXTRA_EXITING :: ldh [hModeState], a

	ld de, rModes_modeLobby
	jp CurtainModeTransitionBegin
:

	ret

