include "hardware.inc"
include "banker.rgbinc"
include "mode.rgbinc"
include "coord.rgbinc"
include "sim/entity.rgbinc"


	mode_def modeGamePrep, modeGamePrep_ExtraFuncs
	mode_def modeGame


section "modeGamePrep", romx
modeGamePrep_ExtraFuncs::
	dw _load0
	dw _load1
	dw _load2
	dw _done


_load0:
	call ModeLoadWaitVx :: ret nc

	; BG tiles part 1
	ld b, bank("assets/enviro0.chr")
	ld de, startof("assets/enviro0.chr")
	ld c, sizeof("assets/enviro0.chr") / 2 / 16 - 1
	ld hl, $9000
	jp VxLoadRom


_load1:
	call ModeLoadWaitVx :: ret nc

	; BG tiles part 2
	ld b, bank("assets/enviro0.chr")
	ld de, startof("assets/enviro0.chr") + sizeof("assets/enviro0.chr") / 2
	ld c, sizeof("assets/enviro0.chr") / 2 / 16 - 1
	ld hl, $9000 + sizeof("assets/enviro0.chr") / 2
	jp VxLoadRom


_load2:
	call ModeLoadWaitVx :: ret nc

	; BG palettes
	ld de, startof("assets/enviro0.chr.pal")
	ld c, sizeof("assets/enviro0.chr.pal") / 8
	ld b, 0
	ld h, bank("assets/enviro0.chr.pal")
	jp PalettesLoadRomx


_done:
	call ModeLoadWaitVx :: ret nc

	ld a, MODE_STATE_PROCESS :: ldh [hModeState], a
	jp CurtainOpen


modeGamePrep_Enter::
	ld b, bank("assets/character_test.chr")
	ld de, startof("assets/character_test.chr")
	ld c, sizeof("assets/character_test.chr") / 16 - 1
	ld hl, $8100
	call VxLoadRom

	ld de, startof("assets/character_test.chr.pal")
	ld c, 1
	ld b, 8
	ld h, bank("assets/character_test.chr.pal")
	call PalettesLoadRomx

	call ScrollInit
	call PlayerInit
	call EntityInit
	call CollideInit
	call MapOpen

	ld a, MODE_STATE_EXTRA :: ldh [hModeState], a
	ret


modeGamePrep_Process::
	ld de, rModes_modeGame
	jp ModeSetActive


section "modeGame", romx
modeGame_Enter::
	ld a, MODE_STATE_PROCESS :: ldh [hModeState], a
	ret


modeGame_Process::
	call PlayerUpdate

/*
	; debugfly: override player input
	ldh a, [hKeys]
	ld b, a
	xor a
	bit PADB_UP, b
	jr z, :+
	dec a
:
	bit PADB_DOWN, b
	jr z, :+
	inc a
:
	add a :: add a :: add a
	ld [wEntity + 6], a
	xor a
	bit PADB_LEFT, b
	jr z, :+
	dec a
:
	bit PADB_RIGHT, b
	jr z, :+
	inc a
:
	add a :: add a :: add a
	ld [wEntity + 2], a
*/

	call EntityUpdate
	call _ViewTargetThing

	call ScrollUpdate
	ld a, [wScroll.y + 0] :: ld [wSCY], a
	ld a, [wScroll.x + 0] :: ld [wSCX], a
	call MapUpdate

/*
	; paint trail ~~ coord verify/test
	; coord Y -> BG grid offset
	ld a, [wEntity + 8 + 0]
	rla
	ld a, [wEntity + 8 + 1]
	rla
	add a ; * 2
	add a ; * 4
	add a ; * 8
	ld l, a
	ld h, 0
	add hl, hl ; * 16
	add hl, hl ; * 32

	; coord X -> BG grid offset
	ld a, [wEntity + 4 + 0]
	rla
	ld a, [wEntity + 4 + 1]
	rla
	and $1F
	add l
	ld l, a
	adc h
	sub l
	add high(wMapBgAtrb)
	ld h, a

	; cycle BG tile palette
	wrambpush bank(wMapBgAtrb)
	ld a, [hl]
	ld b, a
	inc b
	xor b
	and $F8
	xor b
	ld [hl], a
	wrambpop
*/

	; After scrolling, adjust target object position
	ld a, [wTargetThing.y] :: ld b, a
	ldh a, [hScrollAppliedY]
	cpl :: inc a :: add b :: add ENT_SPRITE_Y_OFF :: ld b, a
	ld a, [wTargetThing.x] :: ld c, a
	ldh a, [hScrollAppliedX]
	cpl :: inc a :: add c :: add ENT_SPRITE_X_OFF :: ld c, a

	; dirty test to show entity position
	ld d, 16
	ld e, 0
	call ObdoSingle
	inc d :: inc d
	ld a, c :: add 8 :: ld c, a
	call ObdoSingle

	ret


;; Scroll view if target is more than this distance from the screen centre.
def SCROLL_FENCE equ 24


;; @param C: dCentre -- target position relative to view centre
;; @ret A: scroll delta
_ScrollFenceThing:
	ld a, c
	and a
	ret z
	rlca
	jr c, .negative
.positive
	ld a, c
	sub SCROLL_FENCE
	ret nc
	xor a
	ret
.negative
	ld a, c
	sub -SCROLL_FENCE
	ret c
	xor a
	ret


_ViewTargetThing:
	; player entity Y position
	ld a, [wEntity + 8 + 0] :: ld c, a
	ld a, [wEntity + 8 + 1] :: ld b, a
	coord_int16 bc

	; view rect centre
	ld a, [wScroll.y + 0]
	add 144 / 2 :: ld e, a
	ld a, [wScroll.y + 1]
	adc e :: sub e :: ld d, a

	coord_sub bc, de
	ld a, c :: add 144 / 2 :: ld [wTargetThing.y], a
	call _ScrollFenceThing
	ld [wScroll.dy], a

	; player entity X position
	ld a, [wEntity + 4 + 0] :: ld c, a
	ld a, [wEntity + 4 + 1] :: ld b, a
	coord_int16 bc

	; view rect centre
	ld a, [wScroll.x + 0]
	add 160 / 2 :: ld e, a
	ld a, [wScroll.x + 1]
	adc e :: sub e

	coord_sub bc, de
	ld a, c :: add 160 / 2 :: ld [wTargetThing.x], a
	call _ScrollFenceThing
	ld [wScroll.dx], a

	ret


section "wTargetThing", wram0
wTargetThing::
	.y:: db
	.x:: db

