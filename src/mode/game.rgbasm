include "hardware.inc"
include "banker.rgbinc"
include "mode.rgbinc"
include "coord.rgbinc"
include "sim/entity.rgbinc"


	mode_def modeGamePrep, modeGamePrep_ExtraFuncs
	mode_def modeGame


section "modeGamePrep", romx
modeGamePrep_ExtraFuncs::
	dw _load0
	dw _load1
	dw _load2
	dw _done


_load0:
	call ModeLoadWaitVx :: ret nc

	; BG tiles part 1
	ld b, bank("assets/enviro0.chr")
	ld de, startof("assets/enviro0.chr")
	ld c, sizeof("assets/enviro0.chr") / 2 / 16 - 1
	ld hl, $9000
	jp VxLoadRom


_load1:
	call ModeLoadWaitVx :: ret nc

	; BG tiles part 2
	ld b, bank("assets/enviro0.chr")
	ld de, startof("assets/enviro0.chr") + sizeof("assets/enviro0.chr") / 2
	ld c, sizeof("assets/enviro0.chr") / 2 / 16 - 1
	ld hl, $9000 + sizeof("assets/enviro0.chr") / 2
	jp VxLoadRom


_load2:
	call ModeLoadWaitVx :: ret nc

	; BG palettes
	ld de, startof("assets/enviro0.chr.pal")
	ld c, sizeof("assets/enviro0.chr.pal") / 8
	ld b, 0
	ld h, bank("assets/enviro0.chr.pal")
	jp PalettesLoadRomx


_done:
	call ModeLoadWaitVx :: ret nc

	call MapSyncVisible

	ld a, MODE_STATE_PROCESS :: ldh [hModeState], a
	jp CurtainOpen


modeGamePrep_Enter::
	call VisDiverResourceInit

	call QuestInit
	call ScrollInit
	call EntityInit
	call PlayerInit
	call CollideInit
	call ItemsInit
	call MapOpen

	call MapGetPlayerStart
	coord_from_dots16 bc
	coord_from_dots16 de

	xor a ; player entity index
	call PlayerSpawn

	call ItemsSetupSpecial

	ld a, MODE_STATE_EXTRA :: ldh [hModeState], a
	ret


modeGamePrep_Process::
	ldh a, [hCurtain]
	bit bCurtain_STEADY, a
	ret z

	ld de, rModes_modeGame
	jp ModeSetActive


section fragment "modeGame", romx
modeGame_Enter::
	call MapViewerInit
	ld a, MODE_STATE_PROCESS :: ldh [hModeState], a
	ret


modeGame_Process::
	call EntityUpdate
	call _ViewUpdate

	call _ItemsUpdateCollision
	call ItemsUpdate

	call ScrollUpdate
	ld a, [wScroll.y + 0] :: ld [wSCY], a
	ld a, [wScroll.x + 0] :: ld [wSCX], a
	call MapUpdate
	call EntityRender

	ret


_ItemsUpdateCollision:
	; Use player position as Items collide point
	ld a, [wPlayer.ent]
	call EntityAt
	jr nc, .disable_item_collision

	ld a, [hl] ; .Info
	and ENTINFOF_INVIEW
	jr z, :+
	entity_index Entity_DispX
	ld a, [hl+] :: ld e, a
	ld a, [hl+] :: ld d, a
	ld a, 1
:
	jp ItemsSetCollidePoint
.disable_item_collision
	xor a
	jp ItemsSetCollidePoint


_ViewUpdate:
	; MapViewer overrides view following the target entity.
	ldh a, [hOptA]
	bit bOpt_MapViewer, a
	jp nz, MapViewerUpdate

	jp PlayerViewTarget

