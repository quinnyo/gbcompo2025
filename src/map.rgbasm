include "map.rgbinc"
include "hardware.inc"
include "banker.rgbinc"


def MAP_SIZE equ 32 * 32
def MAP_CHUNK_SIZE equ 16 * 16
def MAP_CHUNK_BUFFER_COUNT equ 9
def MAP_CHR_BUFFER_BANK equ 6
def MAP_ATRB_BUFFER_BANK equ 7


;; Slot status enum/flags
rsreset
;; Slot status bit range used for assigned buffer ID.
;; Buffer ID is the identifying bits of the buffer's address: `id = high(addr) - $D0`
def bSLOT_BUFFER rb 4
;; Set after the chunk in the slot has been rendered.
def bSLOT_RENDERED rb 1
;; Set if there is no chunk to render in the slot.
def bSLOT_NOCHUNK rb 1

def SLOT_BUFFER equ $0F
def SLOT_RENDERED equ 1 << bSLOT_RENDERED
def SLOT_NOCHUNK  equ 1 << bSLOT_NOCHUNK


;; Bits used to store source slot index.
def bSynXfer_SLOT_INDEX equ 0
;; Equivalent to source slot SLOT_RENDERED.
def bSynXfer_SLOT_RENDERED equ bSLOT_RENDERED
;; Equivalent to source slot SLOT_NOCHUNK.
def bSynXfer_SKIP equ bSLOT_NOCHUNK
def bSynXfer_DONE equ 6
;; Set if transfer is for a column (& needs appropriate stride applied)
def bSynXfer_ORIENTATION equ 7

def SynXfer_SLOT_INDEX equ $0F
def SynXfer_SLOT_RENDERED equ 1 << bSynXfer_SLOT_RENDERED
def SynXfer_SKIP equ 1 << bSynXfer_SKIP
def SynXfer_DONE equ 1 << bSynXfer_DONE
def SynXfer_COLUMN equ 1 << bSynXfer_ORIENTATION

def SynXfer_EMPTY equ SynXfer_SKIP


rsreset
;; Status, config, & source slot index.
def SynXfer_status rb 1
;; Transfer length (number of bytes).
def SynXfer_length rb 1
;; Starting index/offset in BG map destination.
def SynXfer_destIndex rb 2
;; Starting index/offset in source chunk.
def SynXfer_srcIndex rb 1
;;; High byte of source buffer address.
;def SynXfer_srcBuffer rb 1

;; Size of SynXfer struct.
def szSynXfer rb 0

def SYN_XFER_COUNT equ 3


section "hMap", hram
;; Bank of the selected map
hMapBank:: db
;; Selected map address
hMapAddr:: dw

hMapViewChunkY: db
hMapViewChunkX: db
hMapViewChunkNewY: db
hMapViewChunkNewX: db
hMapChunkSlots: ds MAP_CHUNK_BUFFER_COUNT
hMapChunkSlotsScratch: ds 3

;; The index of the next chunk slot to update
hMapSlotIdx: db

hMapSrcOriginY: db
hMapSrcOriginX: db


section "hXfer", hram
_destY: db
_destX: db

for I, SYN_XFER_COUNT
_Xfer{d:I}: ds szSynXfer
endr

;; For temporary storage of xfer status during xfer processing.
_xfer_status: db


section "wMapBgChr", wram0[$C800]
;; BG map CHR buffer
wMapBgChr:: ds MAP_SIZE


section "wMapBgAtrb", wramx[$D800], bank[MAP_ATRB_BUFFER_BANK]
;; BG map attribute buffer
wMapBgAtrb:: ds MAP_SIZE


for I, MAP_CHUNK_BUFFER_COUNT
	if I < 8
		def _addr equ $D000 + $100 * I
	else
		def _addr equ $D000 + $100 * I + $400
	endc

	;; Buffer ID
	def CHUNK_BUFFER_{d:I} equ high(_addr) & SLOT_BUFFER

	section "wMapBufferChr{d:I}", wramx[_addr], bank[MAP_CHR_BUFFER_BANK]
	wMapBufferChr{d:I}:: ds MAP_CHUNK_SIZE

	section "wMapBufferAtrb{d:I}", wramx[_addr], bank[MAP_ATRB_BUFFER_BANK]
	wMapBufferAtrb{d:I}:: ds MAP_CHUNK_SIZE

	purge _addr
endr


section "MapEnable", rom0
;; @mut: AF
MapEnable::
	ld a, bank(map_test) :: ldh [hMapBank], a
	ld a, low(map_test) :: ldh [hMapAddr + 0], a
	ld a, high(map_test) :: ldh [hMapAddr + 1], a
	ret


section "MapSelect", rom0
MapSelect::
	ret


section "MapUpdate", rom0
MapUpdate::
	; Map address of $FFxx is 'unset'
	ldh a, [hMapAddr + 1]
	inc a
	ret z

	call MapUpdateViewChunk
	call MapUpdateCache

	;call _ProcessAllSynXfers

	ldh a, [hScrollStat]
	bit bScrollStat_ChangeFrontY, a
	jr z, :+
	ldh a, [hScrollFrontY]
	ld e, a
	call MapSyncFrontRow
:

	ldh a, [hScrollStat]
	bit bScrollStat_ChangeFrontX, a
	jr z, :+
	ldh a, [hScrollFrontX]
	ld e, a
	call MapSyncFrontColumn
:

	ret


section "MapSyncFront", rom0
;; @param E: Y
;; @mut: AF, BC, DE, HL
MapSyncFrontRow::
	; row X position
	ld a, [wScroll.column + 0]
	dec a ; viewX - 1 so corners get painted
	and $1F :: ldh [_destX], a
	ld b, a

	ld a, e :: and $1F :: ldh [_destY], a

	ldh a, [hMapSrcOriginY] :: ld d, a
	ld a, e :: sub d :: ld d, a

	jp MapSyncRow


;; @param E: X
;; @mut: AF, BC, DE, HL
MapSyncFrontColumn:
	; column Y position
	ld a, [wScroll.row + 0]
	dec a ; viewY - 1 so corners get painted
	and $1F :: ldh [_destY], a
	ld b, a

	ld a, e :: and $1F :: ldh [_destX], a

	ldh a, [hMapSrcOriginX] :: ld d, a
	ld a, e :: sub d :: ld d, a

	jp MapSyncColumn


section "MapSync", rom0
;; Initialise sync xfers -- set the srcU start offset and length.
;; @param E: srcU
;; @param C: totalLength
;; @mut: AF, B
SynXferInitialLayout:
	; Reset srcIndex for slot 1 & 2
	xor a
	ldh [_Xfer1 + SynXfer_srcIndex], a
	ldh [_Xfer2 + SynXfer_srcIndex], a
	; srcU will be in slot0 or slot1, so we'll just branch and handle each case separately.
	ld a, e
	cp 16
	jr c, .start_u0
.start_u1 ; if srcU in [16..31]: start in slot 1
	; u1 = srcU - 16
	sub 16 :: ldh [_Xfer1 + SynXfer_srcIndex], a
	; len1 = 16 - u1 = 32 - srcU
	ld a, 32 :: sub e :: ldh [_Xfer1 + SynXfer_length], a
	; len2 = totalLength - len1
	ld b, a
	ld a, c :: sub b :: ldh [_Xfer2 + SynXfer_length], a
	; len0 = 0
	xor a :: ldh [_Xfer0 + SynXfer_length], a
	ret

.start_u0 ; if srcU in [0..15]: start in slot 0
	; u0 = srcU
	ldh [_Xfer0 + SynXfer_srcIndex], a
	; len0 = 16 - u0
	ld a, 16 :: sub e :: ldh [_Xfer0 + SynXfer_length], a
	; lenRemaining = totalLen - len0
	ld b, a :: ld a, c :: sub b
	cp 17
	jr c, .end_u1

.end_u2 ; if lenRemaining > 16: end in slot 2
	; len2 = lenRemaining - len1
	sub 16 :: ldh [_Xfer2 + SynXfer_length], a
	ld a, 16 :: ldh [_Xfer1 + SynXfer_length], a
	ret

.end_u1 ; lenRemaining <= 16: end in slot 1
	; len1 = lenRemaining
	ldh [_Xfer1 + SynXfer_length], a
	xor a :: ldh [_Xfer2 + SynXfer_length], a
	ret


;; Transfer a row from cache to the bgmap buffers.
;; @param B: destX
;; @param D: srcY
;; @mut: AF, BC, DE, HL
MapSyncRow:
	; calculate srcX
	ld a, b
	sub 6 :: and $0F :: add 6
	ld e, a
	ld c, 23
	call SynXferInitialLayout

	; srcV = (srcY % 16) * 16
	ld a, d :: and $0F :: swap a :: ld b, a

	; Set C to the left slot (NW, WW, SW) that contains the row to sync.
	ld c, low(hMapChunkSlots + 0)
	ld a, d
	sub 16
	; if srcY in [0..15]: top 3 slots
	jr c, .finalise
	ld c, low(hMapChunkSlots + 3)
	sub 16
	; if srcY in [16..31]: middle 3 slots
	jr c, .finalise
	ld c, low(hMapChunkSlots + 6)
	; else srcY in [32..47]: bottom 3 slots

.finalise:
	ld hl, _Xfer0
	call _FinaliseRowXfer
	ld hl, _Xfer1
	call _FinaliseRowXfer
	ld hl, _Xfer2
	call _FinaliseRowXfer

	jp _ProcessAllSynXfers


;; @param B: common buffer offset
;; @param C: low byte pointer to slot status
;; @param HL: pointer to SynXfer
;;;;;;;;;;; @mut: AF, DE, HL
_FinaliseRowXfer:
	; status -- slot index & flags
	ld a, c :: sub low(hMapChunkSlots)
	ld d, a
	ldh a, [c]
	and SLOT_RENDERED | SLOT_NOCHUNK
	or d
	ld [hl+], a ; .status

	; Check xfer length
	ld a, [hl] ; .length
	and a
	jr z, .end

	; Destination address from grid position
	ldh a, [_destY]
	; Multiply Y by 32. The result requires 2 bytes but initially both bytes are combined.
	swap a :: rlca
	ld e, a
	; The lowest 5 bits are the high byte of the result.
	and $1F :: ld d, a
	; Finally, subtract the high byte from the combined result to get the low byte on its own.
	; NOTE: adding the X offset here won't cause overflow, assuming a valid value in `[0..31]`.
	ldh a, [_destX] :: add e :: sub d :: ld e, a

	; Advance destination X coord by xfer length
	ldh a, [_destX]
	add [hl] :: and $1F
	ldh [_destX], a
	inc hl

	; Store dest index
	ld a, e :: ld [hl+], a ; dest.0
	ld a, d :: ld [hl+], a ; dest.1

	; If slot has NOCHUNK set, this xfer will be skipped & we have nothing else to do.
	; NOTE: this check must come after updating destination coord.
	ldh a, [c]
	bit bSLOT_NOCHUNK, a
	jr nz, .end

	; srcIndex -- source address low byte
	ld a, [hl] ; .srcIndex holds srcU initially
	add b
	ld [hl+], a ; srcIndex

.end:
	inc c
	ret


;; Transfer a column from cache to the bgmap buffers.
;; @param B: destY
;; @param D: srcX
;; @mut: AF, BC, DE, HL
MapSyncColumn:
	; calculate srcY: starting row, top row of view rect
	ld a, b
	sub 7 :: and $0F :: add 7
	ld e, a
	ld c, 21
	call SynXferInitialLayout

	; srcV = srcX % 16
	ld a, d :: and $0F :: ld b, a

	; Set C to the top slot (NW, NN, NE) that contains the column to sync. (*the column being sunc*)
	ld c, low(hMapChunkSlots)
	ld a, d
	sub 16
	; if srcX in [0..15]: west 3 slots
	jr c, .finalise
	inc c
	sub 16
	; if srcX in [16..31]: middle 3 slots
	jr c, .finalise
	inc c
	; else srcX in [32..47]: east 3 slots

.finalise:
	ld hl, _Xfer0
	call _FinaliseColumnXfer
	ld hl, _Xfer1
	call _FinaliseColumnXfer
	ld hl, _Xfer2
	call _FinaliseColumnXfer

	jp _ProcessAllSynXfers


;; @param B: common buffer offset ... srcX
;; @param C: low byte pointer to slot status
;; @param HL: pointer to xfer params
;;;;;;;;;;; @mut: AF, DE, HL
_FinaliseColumnXfer:
	; status -- slot index & flags
	ld a, c :: sub low(hMapChunkSlots)
	or SynXfer_COLUMN
	ld d, a
	ldh a, [c]
	and SLOT_RENDERED | SLOT_NOCHUNK
	or d
	ld [hl+], a ; .status

	; Check xfer length
	ld a, [hl+] ; .length
	and a
	jr z, .end
	ld d, a
	; Destination address from grid position
	ldh a, [_destY] :: ld e, a
	; Advance destination Y coord by xfer length
	add d :: and $1F
	ldh [_destY], a
	; Multiply Y by 32. The result requires 2 bytes but initially both bytes are combined.
	ld a, e :: swap a :: rlca
	ld e, a
	; The lowest 5 bits are the high byte of the result.
	and $1F :: ld d, a
	; Finally, subtract the high byte from the combined result to get the low byte on its own.
	; NOTE: adding the X offset here won't cause overflow, assuming a valid value in `[0..31]`.
	ldh a, [_destX] :: add e :: sub d
	; ld e, a
	; ld a, e
	ld [hl+], a ; dest.0
	ld a, d :: ld [hl+], a ; dest.1

	; If slot has NOCHUNK set, this xfer will be skipped & we have nothing else to do.
	; NOTE: this check must come after updating destination coord.
	ldh a, [c]
	bit bSLOT_NOCHUNK, a
	jr nz, .end

	; srcIndex -- source address low byte
	ld a, [hl] ; .srcIndex holds srcU initially
	; srcIndex = srcV + (srcU % 16) * 16
	and $0F :: swap a :: add b
	ld [hl+], a ; srcIndex

.end:
	inc c :: inc c :: inc c ; C += 3
	ret


_ProcessAllSynXfers:
	; Process the transfers -- update the BG map
	wrambpush

	ld hl, _Xfer0
	call _ProcessSynXfer
	ld hl, _Xfer1
	call _ProcessSynXfer
	ld hl, _Xfer2
	call _ProcessSynXfer

	wrambpop
	ret


;; @param HL: pointer to SynXfer
;; @mut: AF, BC, DE, HL
_ProcessSynXfer:
	ld a, [hl] ; .status
	ldh [_xfer_status], a
	; Check Xfer needs doing
	and SynXfer_SKIP | SynXfer_DONE
	ret nz

	; get source slot index
	ldh a, [_xfer_status]
	and SynXfer_SLOT_INDEX
	cp 10 :: ret nc ; TODO: probably redundant (SKIP should be set, RENDERED should not be)
	add low(hMapChunkSlots)
	ld c, a
	; check slot's current status
	; TOMAYBEDO: also check that slot is the same as when the Xfer was configured...
	ldh a, [c]
	bit bSLOT_RENDERED, a
	ret z

	; mark xfer as DONE
	set bSynXfer_DONE, [hl]
	inc hl

	; Check that xfer length is nonzero
	ld a, [hl+] ; .length
	and a :: ret z
	ld b, a

	; .destIndex
	ld a, [hl+] :: ld e, a
	ld a, [hl+] :: ld d, a

	; .srcIndex (src address low byte)
	ld l, [hl]
	; src buffer address (high byte)
	ldh a, [c] :: and SLOT_BUFFER :: or $D0
	ld h, a

	; keep xfer status in C
	ldh a, [_xfer_status]
	ld c, a

	ld a, MAP_CHR_BUFFER_BANK :: ldh [rSVBK], a
	push bc :: push de :: push hl
	ld a, d :: add high(wMapBgChr) :: ld d, a

	bit bSynXfer_ORIENTATION, c
	call _xfer_loop

	ld a, MAP_ATRB_BUFFER_BANK :: ldh [rSVBK], a
	pop hl :: pop de :: pop bc
	ld a, d :: add high(wMapBgAtrb) :: ld d, a

	bit bSynXfer_ORIENTATION, c
	jr _xfer_loop


;; @param B: length
;; @param DE: destination address
;; @param HL: source address
;; @param F.Z: Z = orientation is ROW, NZ = orientation is COLUMN
;; @mut: AF, B, DE, HL
_xfer_loop:
	jr z, .xfer_loop_row
.xfer_loop_column:
	ld a, [hl]
	ld [de], a

	ld a, 32
	add e :: ld e, a
	adc d :: sub e :: ld d, a

	ld a, 16
	add l :: ld l, a
	adc h :: sub l :: ld h, a

	dec b
	jr nz, .xfer_loop_column
	ret

.xfer_loop_row:
	ld a, [hl+]
	ld [de], a :: inc de
	dec b
	jr nz, .xfer_loop_row
	ret


section "MapSlotInfo", rom0
SlotInfo:
db -1, -1
db -1, 0
db -1, 1
db 0, -1
db 0, 0
db 0, 1
db 1, -1
db 1, 0
db 1, 1


section "MapUpdateSlot", rom0
;; Render the chunk in the given slot, if it hasn't been already.
;; @param L: index
;; @mut: AF, BC, DE, HL
MapUpdateSlot:
	ld a, l :: add low(hMapChunkSlots) :: ld c, a
	ldh a, [c]
	and SLOT_RENDERED | SLOT_NOCHUNK
	ret nz
	ldh a, [c]
	or SLOT_NOCHUNK
	ldh [c], a

	ld a, l :: add a ; index * 2
	add low(SlotInfo) :: ld l, a
	adc high(SlotInfo) :: sub l :: ld h, a

	ldh a, [hMapViewChunkY]
	add [hl] :: inc hl
	ld d, a

	ldh a, [hMapViewChunkX]
	add [hl]
	ld e, a

	; Chunk lookup
	ld hl, hMapAddr
	ld a, [hl+] :: ld h, [hl] :: ld l, a ; hMapAddr
	ld a, [hl+] :: ld h, [hl] :: ld l, a ; map.chunk_table
	call MapChunkLookup
	ret nc

	; DE = chunk buffer dest
	ldh a, [c] :: and SLOT_BUFFER :: or $D0
	ld d, a :: ld e, 0
	push de
;	push hl
	; skip atrb brushes
	inc hl :: inc hl
	ld a, MAP_CHR_BUFFER_BANK :: ldh [rSVBK], a
	call MapChunkRender

;	pop hl
	pop de
	; pointer to atrb brushes
;	ld a, [hl+] :: ld h, [hl] :: ld l, a
	ld a, MAP_ATRB_BUFFER_BANK :: ldh [rSVBK], a
	call MapChunkRender

	; update slot status
	ldh a, [c]
	xor SLOT_RENDERED | SLOT_NOCHUNK ; clear NOCHUNK & set RENDERED
	ldh [c], a
	ret


section "MapUpdateCache", rom0
MapUpdateCache:
	rombpush
	ldh a, [hMapBank]
	ld [$2000], a
	wrambpush

	call _UpdateNext
	call _UpdateNext
	;call _UpdateNext

	wrambpop
	rombpop
	ret


_UpdateNext:
	ldh a, [hMapSlotIdx] :: ld l, a
	inc a
	cp MAP_CHUNK_BUFFER_COUNT
	jr c, :+
	xor a
:
	ldh [hMapSlotIdx], a
	jp MapUpdateSlot


section "MapUpdateViewChunk", rom0
;; Update visible chunks from scroll position.
;; @mut: AF, HL
MapUpdateViewChunk:
	; Y axis view position (world dots) to chunk coords
	ld hl, wScroll.y
	ld a, [hl+]
	ld h, [hl]
	add 72 ; offset to view rect centre
	ld l, a
	adc h
	sub l
	ld h, a
	; divide by 128: hi.0 <~~ lo.7
	ld a, l
	rla
	ld a, h
	rla
	ldh [hMapViewChunkNewY], a
	dec a :: swap a :: and $F0 :: ldh [hMapSrcOriginY], a

	; X axis view position (world dots) to chunk coords
	ld hl, wScroll.x
	ld a, [hl+]
	ld h, [hl]
	add 80 ; offset to view rect centre
	ld l, a
	adc h
	sub l
	ld h, a
	; divide by 128: hi.0 <~~ lo.7
	ld a, l
	rla
	ld a, h
	rla
	ldh [hMapViewChunkNewX], a
	dec a :: swap a :: and $F0 :: ldh [hMapSrcOriginX], a

	call _UpdateSlotsY
	ldh a, [hMapViewChunkNewY]
	ldh [hMapViewChunkY], a

	call _UpdateSlotsX
	ldh a, [hMapViewChunkNewX]
	ldh [hMapViewChunkX], a

	ret


_UpdateSlotsY:
	ldh a, [hMapViewChunkY]
	ld l, a
	ldh a, [hMapViewChunkNewY]
	sub l
	ret z
;	jp _ResetAllSlots
	jr c, .neg
	; (newY - Y) > 0: scroll down ~~ shift up
	dec a
	jp z, _SlotsShiftUp
	jp _ResetAllSlots
.neg
	; (newY - Y) < 0: scroll up ~~ shift down
	inc a
	jp z, _SlotsShiftDown
	jp _ResetAllSlots


_UpdateSlotsX:
	ldh a, [hMapViewChunkX]
	ld l, a
	ldh a, [hMapViewChunkNewX]
	sub l
	ret z
;	jp _ResetAllSlots
	jr c, .neg
	; (newX - X) > 0: scroll right ~~ shift left
	dec a
	jp z, _SlotsShiftLeft
	jp _ResetAllSlots
.neg
	; (newX - X) < 0: scroll left ~~ shift right
	inc a
	jp z, _SlotsShiftRight
	jp _ResetAllSlots


_ResetAllSlots:
for I, MAP_CHUNK_BUFFER_COUNT
	ld a, CHUNK_BUFFER_{d:I} :: ldh [hMapChunkSlots + I], a
endr
	ret


section "MapSlotsShift", rom0
_SlotsShiftUp:
	ld hl, hMapChunkSlots
	ld a, [hl+] :: and SLOT_BUFFER :: ldh [hMapChunkSlotsScratch + 0], a
	ld a, [hl+] :: and SLOT_BUFFER :: ldh [hMapChunkSlotsScratch + 1], a
	ld a, [hl+] :: and SLOT_BUFFER :: ldh [hMapChunkSlotsScratch + 2], a
for I, MAP_CHUNK_BUFFER_COUNT
	ld a, [hl+] :: ldh [hMapChunkSlots + I], a
endr
	ret


_SlotsShiftDown:
	ld hl, hMapChunkSlotsScratch + 2
for I, MAP_CHUNK_BUFFER_COUNT
	ldh a, [hMapChunkSlots + MAP_CHUNK_BUFFER_COUNT - I - 1] :: ld [hl-], a
endr
	ldh a, [hMapChunkSlotsScratch + 2] :: and SLOT_BUFFER :: ld [hl-], a
	ldh a, [hMapChunkSlotsScratch + 1] :: and SLOT_BUFFER :: ld [hl-], a
	ldh a, [hMapChunkSlotsScratch + 0] :: and SLOT_BUFFER :: ld [hl-], a
	ret


_SlotsShiftLeft:
	ld hl, hMapChunkSlots

for I, 3
	ld b, [hl]
	ldh a, [hMapChunkSlots + I * 3 + 1] :: ld [hl+], a
	ldh a, [hMapChunkSlots + I * 3 + 2] :: ld [hl+], a
	ld a, b :: and SLOT_BUFFER :: ld [hl+], a
endr
	ret


_SlotsShiftRight:
	ld hl, hMapChunkSlots

for I, 3
	ld b, [hl]
	ldh a, [hMapChunkSlots + I * 3 + 2] :: and SLOT_BUFFER :: ld [hl+], a
	ld a, b :: ld b, [hl] :: ld [hl+], a
	ld a, b :: ld [hl+], a
endr
	ret


section "MapChunkTransfer", rom0
;; Copy a chunk (16 * 16) to a bg map buffer (32 * 32)
;; @param DE: source (chunk buffer)
;; @param HL: dest (bg map)
;; @mut: AF, BC, DE, HL
MapChunkTransfer::
	ld b, 16 ; Y
	ld c, b ; X
.loop
	ld a, [de] :: inc de
	ld [hl+], a
	dec c
	jr nz, .loop
	; bg map is 32 wide, so add an additional 16 to `dest` (HL)
	ld a, 16
	ld c, a ; reset C also!
	add l :: ld l, a
	adc h :: sub l :: ld h, a

	dec b
	jr nz, .loop
	ret


section "MapChunkRender", rom0
;; Render a chunk to a chunk buffer.
;; @param HL: source chunk brushes
;; @param DE: dest (chunk buffer)
;; @mut: AF, B, DE, HL
MapChunkRender::
.continue:
	ld a, [hl+]
	and BR__TYPE
	assert BR_TERM == 0
	ret z
	assert BR_SOLID == 1
	dec a :: jr z, .br_solid

.err_unhandled_brush:
	ld b, b
	jr .err_unhandled_brush

.br_solid:
	ld a, [hl+]
	ld b, a
	inc b ; brush data has length - 1
	ld a, [hl+]
:
	ld [de], a :: inc de
	dec b
	jr nz, :-
	jr .continue


/*
section "test/map/chunk_render", rom0
Test_map_chunk_render:
	rombopen bank(map_test)
	ld hl, map_test.chunk_table
	ld de, (0 << 8) | 4
	call MapChunkLookup
	jr nc, .err
	; skip 2 byte atrb pointer
	inc hl :: inc hl

	wrambpush bank(wMapBufferChr0)
	ld de, wMapBufferChr0
	call MapChunkRender

	ld de, wMapBufferChr0
	ld hl, wMapBgChr
	call MapChunkTransfer
	wrambpop

	ret
.err:
	ld b, b
	halt :: nop
	jr .err
*/


section "MapChunkLookup", rom0
;; @param HL: Chunk Table
;; @param D,E: row,column
;; @ret HL: Chunk
;; @ret F.C: set if successful
;; @mut: AF, B, HL
MapChunkLookup::
	ld a, [hl+]
	ld b, a
:
	ld a, [hl+]
	cp d
	jr z, .xtable
	inc hl :: inc hl
	dec b
	jr nz, :-
	jr .fail
.xtable:
	ld a, [hl+]
	ld h, [hl]
	ld l, a
	ld a, [hl+]
	ld b, a
:
	ld a, [hl+]
	cp e
	jr z, .ok
	inc hl :: inc hl
	dec b
	jr nz, :-
.fail:
	xor a ; clear F.C
	ret
.ok:
	ld a, [hl+]
	ld h, [hl]
	ld l, a
	scf
	ret


/*
section "test/map/chunk_lookup", rom0
Test_map_chunk_lookup::
	ld b, b
for Y, 6
	for X, 6
.test_{d:Y}_{d:X}:
	ld a, bank(map_test)
	ld [$2000], a
	ld hl, map_test.chunk_table
	ld de, (Y << 8) | X
	call MapChunkLookup
	ld b, b
	endr
endr
	ret

*/


section "xMapBufferInit", romx
xMapBufferInit::
	; Clear BG map
	wrambpush bank(wMapBgChr)
	ld hl, wMapBgChr
	ld bc, (MAP_SIZE - 1) + $1_01
:
	ld a, l :: ld [hl+], a
	dec c
	jr nz, :-
	dec b
	jr nz, :-

	; Clear BG attribute map
	ld a, bank(wMapBgAtrb) :: ldh [rSVBK], a
	ld hl, wMapBgAtrb
	ld bc, (MAP_SIZE - 1) + $1_01
	xor a
:
	ld [hl+], a
	dec c
	jr nz, :-
	dec b
	jr nz, :-

	wrambpop
	ret


section "MapInit", rom0
MapInit::
	ld a, $FF
	ldh [hMapBank], a
	ldh [hMapAddr + 0], a
	ldh [hMapAddr + 1], a
	ldh [hMapViewChunkY], a
	ldh [hMapViewChunkX], a
	ld a, $80
	ldh [hMapViewChunkNewY], a
	ldh [hMapViewChunkNewX], a

	call _ResetAllSlots

	xor a :: ldh [hMapSlotIdx], a

	ld b, SYN_XFER_COUNT * szSynXfer
	ld a, SynXfer_EMPTY
	ld c, low(_Xfer0)
:
	ldh [c], a :: inc c
	dec b
	jr nz, :-

	xor a
	ldh [hMapSrcOriginX], a
	ldh [hMapSrcOriginY], a

	rombopen bank(xMapBufferInit)
	jp xMapBufferInit

