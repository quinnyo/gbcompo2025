if !def(Q_CHRIMP_INC_QGZQwjX8)
def Q_CHRIMP_INC_QGZQwjX8 equ 1


;; import_screen SRC, LABEL
;; Import a complete 'screen' image. This is made of several parts, as can be generated by rgbgfx.
;;
;; The data is labelled using LABEL with a suffix appended: `{LABEL}_{EXT}`.
;; The source file path for the tileset CHR data is SRC, unmodified.
;; The source file paths for the other parts are based on SRC with an extension: `{SRC}.{EXT}`.
;; EXT identifies the type of the part being one of:
;; - `chr` (tileset),
;; - `pal` (palettes),
;; - `idx` (screen index map),
;; - `atrb` (screen attribute map)
;;
;; A ROMX section is created for each part with the source path used as the section name.
;; The CHR data is aligned appropriately for HDMA transfers.
;; 
;; Some additional constants are defined:
;; - all parts: `sizeof_{LABEL}_{EXT}`: tile data size in bytes
;; - `{LABEL}_CHR_COUNT`: number of tiles in the tileset
;;   - Use `{LABEL}_CHR_COUNT - 1` to configure HDMA transfer length.
;; - `{LABEL}_PALETTE_COUNT`: number of palettes
macro import_screen
	pushs \1, romx, align[4]
	\2_chr:: incbin \1
	def sizeof_\2_chr equ @ - \2_chr
	def \2_CHR_COUNT equ sizeof_\2_chr / 16
	pops

	pushs strcat(\1, ".idx"), romx
	\2_idx:: incbin strcat(\1, ".idx")
	def sizeof_\2_idx equ @ - \2_idx
	pops

	pushs strcat(\1, ".atrb"), romx
	\2_atrb:: incbin strcat(\1, ".atrb")
	def sizeof_\2_atrb equ @ - \2_atrb
	pops

	pushs strcat(\1, ".pal"), romx
	\2_pal:: incbin strcat(\1, ".pal")
	def sizeof_\2_pal equ @ - \2_pal
	def \2_PALETTE_COUNT equ sizeof_\2_pal / 8
	pops
endm


;; Helper macro for loading CHR data via Vx, particularly for tilesets that are larger
;; than one CHR block (128 tiles).
;;
;; Initial invocation: setup and perform the first transfer.
;;   load_chr DEST_START, DEST_END, SRC_SECTION, [SRC_SIZE]
;;   load_chr DEST_START, DEST_END, SRC_LABEL, SRC_SIZE
;;   load_chr DEST_START, DEST_END, SRC_ADDR, SRC_BANK, SRC_SIZE
;; 
;; Subsequent invocation: perform another transfer with the overflow.
;;   load_chr DEST_START, DEST_END
;;
;; DEST_START: destination address in VRAM (e.g. $9000)
;; DEST_END: destination region extent (e.g. $9800)
;; SRC_SECTION: The section containing the source data exclusively if SRC_SIZE omitted.
;;              With SRC_SIZE, the source data must begin at the start of the section.
;; SRC_LABEL: Label at start of source data.
;; SRC_ADDR,SRC_BANK: address & bank of source region.
;; SRC_SIZE: source data size in bytes
;;
;; NOTE ABOUT SOURCE DATA ALIGNMENT:
;; The source data must be aligned appropriately for HDMA transfer (i.e. `align[4]`).
;;
;; The number of tiles transferred is the smallest value out of:
;; destination region capacity; remaining source tile count; 128
;;
;; `CHR_REMAIN` will be defined if there was overflow (untransferred tiles).
;; Trigger additional transfer/s by invoking the macro again with a new destination region.
;;
;; `CHR_DEST_END` will be set to the end of the effective destination region.
macro load_chr
	if !def(CHR_REMAIN)
		assert _NARG > 2, "CHR_REMAIN is undefined. SRC must be specified for the initial invocation."
	else
		assert _NARG == 2, "CHR_REMAIN is defined. Omit SRC in subsequent invocations."
	endc

	assert _NARG >= 2
	def _dest_args equs "\1, \2"
	shift 2

	if _NARG == 1
		; SRC must be section to get bank & size
		def _LOAD_CHR_SRC_ARGS equs "startof(\1), bank(\1), sizeof(\1)"
	elif _NARG == 2
		if strfind("\1", "\"") == 0
			; SRC is quoted string is section name
			def _LOAD_CHR_SRC_ARGS equs "startof(\1), bank(\1), (\2)"
		else
			; SRC is label
			def _LOAD_CHR_SRC_ARGS equs "\1, bank(\1), (\2)"
		endc
	elif _NARG == 3
		; fully specified source
		def _LOAD_CHR_SRC_ARGS equs "(\1), (\2), (\3)"
	elif _NARG != 0
		fail "Arg! Too many args!"
	endc

	_load_chr_go {_dest_args}, {_LOAD_CHR_SRC_ARGS}

	purge _dest_args
	if CHR_REMAIN == 0
		purge CHR_REMAIN, _LOAD_CHR_SRC_ARGS
	endc
endm


;; _load_chr_go DEST_START, DEST_END, SRC_ADDR, SRC_BANK, SRC_SIZE
macro _load_chr_go
	assert _NARG == 5
	if !def(CHR_REMAIN)
		def CHR_REMAIN equ (\5) / 16
		def _src_index equ 0
	else
		def _src_index equ (\5) / 16 - CHR_REMAIN
	endc

	def _start_addr equ (\1)
	def _end_addr equ (\2)
	def _max_count equ (_end_addr - _start_addr) / 16

if CHR_REMAIN > _max_count
	def _chr_count equ _max_count
else
	def _chr_count equ CHR_REMAIN
endc
	redef CHR_REMAIN equ CHR_REMAIN - _chr_count

	ld b, (\4)
	ld de, (\3) + _src_index * 16
	ld c, _chr_count - 1
	ld hl, _start_addr
	call VxLoadRom

	redef CHR_DEST_END equ _start_addr + (_src_index + _chr_count) * 16

	purge _start_addr, _end_addr, _max_count, _src_index, _chr_count
endm


endc ; Q_CHRIMP_INC_QGZQwjX8

