include "hardware.inc"
include "chrimp.rgbinc"
include "coord.rgbinc"
include "vis/diver.rgbinc"
include "banker.rgbinc"
include "sprite.rgbinc"


import_chr "assets/ent/diver-idle-0.chr", DiverIdle_0, pal
import_chr "assets/ent/diver-idle-1.chr", DiverIdle_1, pal
import_chr "assets/ent/diver-move-0.chr", DiverMove_0
import_chr "assets/ent/diver-move-1.chr", DiverMove_1
import_chr "assets/ent/diver-ascend45-0.chr", DiverAscend45_0
import_chr "assets/ent/diver-ascend45-1.chr", DiverAscend45_1
import_chr "assets/ent/diver-descend45-0.chr", DiverDescend45_0
import_chr "assets/ent/diver-descend45-1.chr", DiverDescend45_1

def VIS_DIVER_CHR_IDX equ $10
def VIS_DIVER_CHR_ADDR equ $8000 + VIS_DIVER_CHR_IDX * $10

def ANI_IDLE_FRAME_COUNT equ 4
def ANI_IDLE_FRAMETIME equ 30

def ANI_MOVE_FRAME_COUNT equ 6
def ANI_MOVE_FRAMETIME equ 120

def ANI_ASCEND45_FRAME_COUNT equ 6
def ANI_ASCEND45_FRAMETIME equ 120

def ANI_DESCEND45_FRAME_COUNT equ 6
def ANI_DESCEND45_FRAMETIME equ 120

rsreset
def ANI_IDLE_0_CHRI rb ANI_IDLE_FRAME_COUNT * 2
def ANI_IDLE_1_CHRI rb ANI_IDLE_FRAME_COUNT * 2
def ANI_MOVE_0_CHRI rb ANI_MOVE_FRAME_COUNT * 2
def ANI_MOVE_1_CHRI rb ANI_MOVE_FRAME_COUNT * 2
def ANI_ASCEND45_0_CHRI rb ANI_ASCEND45_FRAME_COUNT * 2
def ANI_ASCEND45_1_CHRI rb ANI_ASCEND45_FRAME_COUNT * 2
def ANI_DESCEND45_0_CHRI rb ANI_DESCEND45_FRAME_COUNT * 2
def ANI_DESCEND45_1_CHRI rb ANI_DESCEND45_FRAME_COUNT * 2
def VIS_DIVER_CHR_COUNT rb 0


def IDLE_SPEED_MAX equ 1


section "VisDiver_ani", romx

;; _frame DURATION, NEXT
macro _frame
	assert fail, _NARG == 2
	db (\1)
	dw (\2)
endm


VisDiver_aniIdle:
		sprob_opts_reset sy:8, si:1
	.f0:
		_frame ANI_IDLE_FRAMETIME, .f1
		sprob_seq 2,  4,  0, ANI_IDLE_0_CHRI + 0 * 2, 0
		sprob_seq 2, -4,  0, ANI_IDLE_1_CHRI + 0 * 2, 1
		sprob_end
	.f1:
		_frame ANI_IDLE_FRAMETIME, .f2
		sprob_seq 2,  4,  0, ANI_IDLE_0_CHRI + 1 * 2, 0
		sprob_seq 2, -4,  0, ANI_IDLE_1_CHRI + 1 * 2, 1
		sprob_end
	.f2:
		_frame ANI_IDLE_FRAMETIME, .f3
		sprob_seq 2,  4,  0, ANI_IDLE_0_CHRI + 2 * 2, 0
		sprob_seq 2, -4,  0, ANI_IDLE_1_CHRI + 2 * 2, 1
		sprob_end
	.f3:
		_frame ANI_IDLE_FRAMETIME, .f0
		sprob_seq 2,  4,  0, ANI_IDLE_0_CHRI + 3 * 2, 0
		sprob_seq 2, -4,  0, ANI_IDLE_1_CHRI + 3 * 2, 1
		sprob_end


VisDiver_aniMove:
		sprob_opts_reset sx:8, si:1
	.f0:
		_frame ANI_MOVE_FRAMETIME, .f1
		sprob_seq 2,  4, -8, ANI_MOVE_0_CHRI + 0 * 2, 0
		sprob_seq 2,  4,  0, ANI_MOVE_1_CHRI + 0 * 2, 1
		sprob_end
	.f1:
		_frame ANI_MOVE_FRAMETIME, .f2
		sprob_seq 2,  4, -8, ANI_MOVE_0_CHRI + 1 * 2, 0
		sprob_seq 2,  4,  0, ANI_MOVE_1_CHRI + 1 * 2, 1
		sprob_end
	.f2:
		_frame ANI_MOVE_FRAMETIME, .f3
		sprob_seq 2,  4, -8, ANI_MOVE_0_CHRI + 2 * 2, 0
		sprob_seq 2,  4,  0, ANI_MOVE_1_CHRI + 2 * 2, 1
		sprob_end
	.f3:
		_frame ANI_MOVE_FRAMETIME, .f4
		sprob_seq 2,  4, -8, ANI_MOVE_0_CHRI + 3 * 2, 0
		sprob_seq 2,  4,  0, ANI_MOVE_1_CHRI + 3 * 2, 1
		sprob_end
	.f4:
		_frame ANI_MOVE_FRAMETIME, .f5
		sprob_seq 2,  4, -8, ANI_MOVE_0_CHRI + 4 * 2, 0
		sprob_seq 2,  4,  0, ANI_MOVE_1_CHRI + 4 * 2, 1
		sprob_end
	.f5:
		_frame ANI_MOVE_FRAMETIME, .f0
		sprob_seq 2,  4, -8, ANI_MOVE_0_CHRI + 5 * 2, 0
		sprob_seq 2,  4,  0, ANI_MOVE_1_CHRI + 5 * 2, 1
		sprob_end


VisDiver_aniAscend45:
		sprob_opts_reset si:1
	.f0:
		_frame ANI_ASCEND45_FRAMETIME, .f1
		sprob_seq 2,  4, -4, ANI_ASCEND45_0_CHRI + 0 * 2, 0, sy:8, sx:0
		sprob_seq 2,  4, -4, ANI_ASCEND45_1_CHRI + 0 * 2, 1, sy:0, sx:8
		sprob_end
	.f1:
		_frame ANI_ASCEND45_FRAMETIME, .f2
		sprob_seq 2,  4, -4, ANI_ASCEND45_0_CHRI + 1 * 2, 0, sy:8, sx:0
		sprob_seq 2,  4, -4, ANI_ASCEND45_1_CHRI + 1 * 2, 1, sy:0, sx:8
		sprob_end
	.f2:
		_frame ANI_ASCEND45_FRAMETIME, .f3
		sprob_seq 2,  4, -4, ANI_ASCEND45_0_CHRI + 2 * 2, 0, sy:8, sx:0
		sprob_seq 2,  4, -4, ANI_ASCEND45_1_CHRI + 2 * 2, 1, sy:0, sx:8
		sprob_end
	.f3:
		_frame ANI_ASCEND45_FRAMETIME, .f4
		sprob_seq 2,  4, -4, ANI_ASCEND45_0_CHRI + 3 * 2, 0, sy:8, sx:0
		sprob_seq 2,  4, -4, ANI_ASCEND45_1_CHRI + 3 * 2, 1, sy:0, sx:8
		sprob_end
	.f4:
		_frame ANI_ASCEND45_FRAMETIME, .f5
		sprob_seq 2,  4, -4, ANI_ASCEND45_0_CHRI + 4 * 2, 0, sy:8, sx:0
		sprob_seq 2,  4, -4, ANI_ASCEND45_1_CHRI + 4 * 2, 1, sy:0, sx:8
		sprob_end
	.f5:
		_frame ANI_ASCEND45_FRAMETIME, .f0
		sprob_seq 2,  4, -4, ANI_ASCEND45_0_CHRI + 5 * 2, 0, sy:8, sx:0
		sprob_seq 2,  4, -4, ANI_ASCEND45_1_CHRI + 5 * 2, 1, sy:0, sx:8
		sprob_end


VisDiver_aniDescend45:
		sprob_opts_reset si:1
	.f0:
		_frame ANI_DESCEND45_FRAMETIME, .f1
		sprob_seq 2,  4, -4, ANI_DESCEND45_0_CHRI + 0 * 2, 0, sy:0, sx:8
		sprob_seq 2,  4,  4, ANI_DESCEND45_1_CHRI + 0 * 2, 1, sy:8, sx:0
		sprob_end
	.f1:
		_frame ANI_DESCEND45_FRAMETIME, .f2
		sprob_seq 2,  4, -4, ANI_DESCEND45_0_CHRI + 1 * 2, 0, sy:0, sx:8
		sprob_seq 2,  4,  4, ANI_DESCEND45_1_CHRI + 1 * 2, 1, sy:8, sx:0
		sprob_end
	.f2:
		_frame ANI_DESCEND45_FRAMETIME, .f3
		sprob_seq 2,  4, -4, ANI_DESCEND45_0_CHRI + 2 * 2, 0, sy:0, sx:8
		sprob_seq 2,  4,  4, ANI_DESCEND45_1_CHRI + 2 * 2, 1, sy:8, sx:0
		sprob_end
	.f3:
		_frame ANI_DESCEND45_FRAMETIME, .f4
		sprob_seq 2,  4, -4, ANI_DESCEND45_0_CHRI + 3 * 2, 0, sy:0, sx:8
		sprob_seq 2,  4,  4, ANI_DESCEND45_1_CHRI + 3 * 2, 1, sy:8, sx:0
		sprob_end
	.f4:
		_frame ANI_DESCEND45_FRAMETIME, .f5
		sprob_seq 2,  4, -4, ANI_DESCEND45_0_CHRI + 4 * 2, 0, sy:0, sx:8
		sprob_seq 2,  4,  4, ANI_DESCEND45_1_CHRI + 4 * 2, 1, sy:8, sx:0
		sprob_end
	.f5:
		_frame ANI_DESCEND45_FRAMETIME, .f0
		sprob_seq 2,  4, -4, ANI_DESCEND45_0_CHRI + 5 * 2, 0, sy:0, sx:8
		sprob_seq 2,  4,  4, ANI_DESCEND45_1_CHRI + 5 * 2, 1, sy:8, sx:0
		sprob_end


section "VisDiver_aniTable", romx
VisDiver_aniTable:
	dw VisDiver_aniIdle
	dw VisDiver_aniMove
	dw VisDiver_aniAscend45
	dw VisDiver_aniDescend45


section "wVisDiver", wram0
wVisDiver_chri: db
wVisDiver_pal0: db


section "VisDiverResourceInit", rom0
VisDiverResourceInit::
	ld b, bank(DiverIdle_0_pal)
	ld de, DiverIdle_0_pal
	call PalettePalLoadObRomx
	ld a, b :: and $07 :: ld [wVisDiver_pal0], a

	ld b, bank(DiverIdle_1_pal)
	ld de, DiverIdle_1_pal
	call PalettePalLoadObRomx

	ld c, VIS_DIVER_CHR_COUNT
	call ChrmanAllocOb
	jr nc, :+
.err_alloc_ob
	ld b, b
	ret
:
	ld a, b :: ld [wVisDiver_chri], a

	ld b, bank(DiverIdle_0_chr)
	ld de, DiverIdle_0_chr
	ld c, DiverIdle_0_CHR_COUNT - 1
		push hl
	call VxLoadRom
		pop hl
	ld de, DiverIdle_0_CHR_COUNT * $10
	add hl, de

	ld b, bank(DiverIdle_1_chr)
	ld de, DiverIdle_1_chr
	ld c, DiverIdle_1_CHR_COUNT - 1
		push hl
	call VxLoadRom
		pop hl
	ld de, DiverIdle_1_CHR_COUNT * $10
	add hl, de

	ld b, bank(DiverMove_0_chr)
	ld de, DiverMove_0_chr
	ld c, DiverMove_0_CHR_COUNT - 1
		push hl
	call VxLoadRom
		pop hl
	ld de, DiverMove_0_CHR_COUNT * $10
	add hl, de

	ld b, bank(DiverMove_1_chr)
	ld de, DiverMove_1_chr
	ld c, DiverMove_1_CHR_COUNT - 1
		push hl
	call VxLoadRom
		pop hl
	ld de, DiverMove_1_CHR_COUNT * $10
	add hl, de

	ld b, bank(DiverAscend45_0_chr)
	ld de, DiverAscend45_0_chr
	ld c, DiverAscend45_0_CHR_COUNT - 1
		push hl
	call VxLoadRom
		pop hl
	ld de, DiverAscend45_0_CHR_COUNT * $10
	add hl, de

	ld b, bank(DiverAscend45_1_chr)
	ld de, DiverAscend45_1_chr
	ld c, DiverAscend45_1_CHR_COUNT - 1
		push hl
	call VxLoadRom
		pop hl
	ld de, DiverAscend45_1_CHR_COUNT * $10
	add hl, de

	ld b, bank(DiverDescend45_0_chr)
	ld de, DiverDescend45_0_chr
	ld c, DiverDescend45_0_CHR_COUNT - 1
		push hl
	call VxLoadRom
		pop hl
	ld de, DiverDescend45_0_CHR_COUNT * $10
	add hl, de

	ld b, bank(DiverDescend45_1_chr)
	ld de, DiverDescend45_1_chr
	ld c, DiverDescend45_1_CHR_COUNT - 1
		push hl
	call VxLoadRom
		pop hl
	ld de, DiverDescend45_1_CHR_COUNT * $10
	add hl, de

	ret


section "VisDiverReset", rom0
;; @param HL: this VisDiver
;; @mut: AF, BC, DE, HL
VisDiverReset::
	xor a
	; y, x
	ld [hl+], a :: ld [hl+], a
	; ctl
	ld [hl+], a
	; state
		push hl
	ld a, VisDiverState__COUNT :: ld [hl+], a
	;
	xor a :: ld [hl+], a

	call AniInit
		pop hl

	ld d, VisDiverState_IDLE
	jp VisDiverSetState.hl_at_state


section "VisDiverSetState", rom0
;; Set animation state directly.
;; @param HL: this VisDiver
;; @param D: new anim state
;; @mut: AF, BC, DE, HL
VisDiverSetState::
	ld bc, VisDiver_state
	add hl, bc

.hl_at_state:
	; check state != new_state and new_state is valid
	ld a, d
	cp VisDiverState__COUNT
	jr nc, .err_out_of_range
	cp [hl]
	ret z
	ld [hl+], a

	; get anim pointer
	ld a, d :: add a ; index * 2
	ld bc, VisDiver_aniTable
	add c :: ld c, a
	adc b :: sub c :: ld b, a
	rombpush bank(VisDiver_aniTable)
	ld a, [bc] :: inc bc :: ld e, a
	ld a, [bc] :: ld d, a
	rombpop

	; update Ani
	assert VisDiver_ani - (VisDiver_state + 1) == 1
	inc hl
	ld b, bank("VisDiver_ani")
	call AniSetFrame

	ret

.err_out_of_range
	ld b, b
	jr .err_out_of_range


section "VisDiverSetCtl", rom0
;; @param A: new ctl value
;; @param HL: this VisDiver
;; @mut: AF, BC, DE, HL
VisDiverSetCtl::
	ld bc, VisDiver_ctl
	add hl, bc

	ld c, a
	ld a, [hl]
	ld b, a

	; Speed
	ld a, c
	and VisDiverCtl_SPEED
	ld d, a
	call _SetSpeed

	; Heading
	call _SetHeading
	ld a, b
	ld [hl+], a
	call _CtlToState

	jp VisDiverSetState.hl_at_state


;; @param B: ctl state
;; @ret D: selected anim state
;; @mut: AF, D
_CtlToState:
	; default to IDLE?
	ld d, VisDiverState_IDLE

	; if speed <= IDLE_SPEED_MAX: IDLE
	ld a, b
	and VisDiverCtl_SPEED
	cp IDLE_SPEED_MAX + 1
	ret c

	; if heading DOWN: DESCEND45
	ld d, VisDiverState_DESCEND45
	ld a, b
	rlca
	ret c

	; if heading UP: ASCEND45
	dec d
	rlca
	ret c

	dec d ; MOVE
	ret


;; @param B: ctl state
;; @param D: target speed
;; @ret B: new ctl state
;; @mut: AF, B
_SetSpeed:
	ld a, d
	and a
	jr nz, :+
	; slowly to stop
	ld a, [wVBlankCount]
	and $07
	ret nz
:
	ld a, b
	and VisDiverCtl_SPEED
	cp d
	ret z

	; +/- 1 (if C/NC)
	sbc a :: cpl :: or 1
	add b
	ld b, a

	ret


;; @param B: ctl state
;; @param C: new heading
;; @ret B: new ctl state
_SetHeading:
	; X axis heading is 'sticky' -- only update to non-zero values.
	ld a, c
	and VisDiverDir_X
	jr z, .do_y_maybe
	xor b
	and VisDiverDir_X
	xor b
	ld b, a

.do_y_maybe
	ld a, c
	xor b
	and VisDiverDir_Y
	xor b
	ld b, a

	ret


section "VisDiverUpdate", rom0
;; @param HL: this VisDiver
VisDiverUpdate::
	rombopen

	ld a, [hl+] :: add 8 :: ld b, a ; y
	ld a, [hl+] :: add 4 :: ld c, a ; x

	ld a, [hl+] ; ctl
	ld e, a
	and VisDiverCtl_SPEED :: ld d, a
	; Flip X if heading left
	ld a, e :: and VisDiverDir_LEFT :: ld e, a

	ld a, [hl+] ; state
	cp VisDiverState_IDLE
	jr nz, :+
	ld d, 1
:

		push bc
		push de

	assert VisDiver_ani - (VisDiver_state + 1) == 1
	inc hl
	call AniUpdate

	rombsel b

		pop de
		pop bc

	; HL: Ani drawable pointer, abort if $FFFF
	ld a, l :: and h
	inc a
	ret z

	ld a, [wVisDiver_chri] :: ld d, a
	ld a, [wVisDiver_pal0] :: or e :: ld e, a

	jp SprxRenderMod

