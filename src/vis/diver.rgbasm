include "hardware.inc"
include "chrimp.rgbinc"
include "coord.rgbinc"
include "vis/diver.rgbinc"
include "banker.rgbinc"
include "sprite.rgbinc"


import_chr "assets/ent/diver-move-0.chr", DiverMove_0, pal
import_chr "assets/ent/diver-move-1.chr", DiverMove_1, pal

def VIS_DIVER_CHR_IDX equ $10
def VIS_DIVER_CHR_ADDR equ $8000 + VIS_DIVER_CHR_IDX * $10

def MOVE_FRAME_COUNT equ 6
def MOVE0_CHRI equ 0
def MOVE1_CHRI equ MOVE0_CHRI + MOVE_FRAME_COUNT * 2 * 2

def MOVE_BASE_FRAMETIME equ 80


section "VisDiver", romx

;; _frame DURATION, NEXT
macro _frame
	assert fail, _NARG == 2
	db (\1)
	dw (\2)
endm


VisDiver_aniMove:
	.right:
		sprob_opts sx:8, si:2, cx, cy
	.f0:
		_frame MOVE_BASE_FRAMETIME, .f1
		sprob_seq 2, 0, -8, MOVE0_CHRI + 0 * 4, 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 0 * 4, 1
		sprob_end
	.f1:
		_frame MOVE_BASE_FRAMETIME, .f2
		sprob_seq 2, 0, -8, MOVE0_CHRI + 1 * 4, 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 1 * 4, 1
		sprob_end
	.f2:
		_frame MOVE_BASE_FRAMETIME, .f3
		sprob_seq 2, 0, -8, MOVE0_CHRI + 2 * 4, 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 2 * 4, 1
		sprob_end
	.f3:
		_frame MOVE_BASE_FRAMETIME, .f4
		sprob_seq 2, 0, -8, MOVE0_CHRI + 3 * 4, 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 3 * 4, 1
		sprob_end
	.f4:
		_frame MOVE_BASE_FRAMETIME, .f5
		sprob_seq 2, 0, -8, MOVE0_CHRI + 4 * 4, 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 4 * 4, 1
		sprob_end
	.f5:
		_frame MOVE_BASE_FRAMETIME, .f0
		sprob_seq 2, 0, -8, MOVE0_CHRI + 5 * 4, 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 5 * 4, 1
		sprob_end

	.left:
		sprob_opts sx:-8, si:2, cx, cy
	.f6:
		_frame MOVE_BASE_FRAMETIME, .f7
		sprob_seq 2, 0,  8, MOVE0_CHRI + 0 * 4, $20 | 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 0 * 4, $20 | 1
		sprob_end
	.f7:
		_frame MOVE_BASE_FRAMETIME, .f8
		sprob_seq 2, 0,  8, MOVE0_CHRI + 1 * 4, $20 | 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 1 * 4, $20 | 1
		sprob_end
	.f8:
		_frame MOVE_BASE_FRAMETIME, .f9
		sprob_seq 2, 0,  8, MOVE0_CHRI + 2 * 4, $20 | 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 2 * 4, $20 | 1
		sprob_end
	.f9:
		_frame MOVE_BASE_FRAMETIME, .f10
		sprob_seq 2, 0,  8, MOVE0_CHRI + 3 * 4, $20 | 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 3 * 4, $20 | 1
		sprob_end
	.f10:
		_frame MOVE_BASE_FRAMETIME, .f11
		sprob_seq 2, 0,  8, MOVE0_CHRI + 4 * 4, $20 | 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 4 * 4, $20 | 1
		sprob_end
	.f11:
		_frame MOVE_BASE_FRAMETIME, .f6
		sprob_seq 2, 0,  8, MOVE0_CHRI + 5 * 4, $20 | 0
		sprob_seq 2, 0,  0, MOVE1_CHRI + 5 * 4, $20 | 1
		sprob_end


section "wVisDiver", wram0
wVisDiver_chri_move: db
wVisDiver_pal0: db


section "VisDiverResourceInit", rom0
VisDiverResourceInit::
	ld b, bank(DiverMove_0_pal)
	ld de, DiverMove_0_pal
	call PalettePalLoadObRomx
	ld a, b :: and $07 :: ld [wVisDiver_pal0], a

	ld b, bank(DiverMove_1_pal)
	ld de, DiverMove_1_pal
	call PalettePalLoadObRomx

	ld a, VIS_DIVER_CHR_IDX :: ld [wVisDiver_chri_move], a
	ld hl, VIS_DIVER_CHR_ADDR
	ld b, bank(DiverMove_0_chr)
	ld de, DiverMove_0_chr
	ld c, DiverMove_0_CHR_COUNT - 1
	call VxLoadRom

	ld hl, VIS_DIVER_CHR_ADDR + DiverMove_0_CHR_COUNT * $10
	ld b, bank(DiverMove_1_chr)
	ld de, DiverMove_1_chr
	ld c, DiverMove_1_CHR_COUNT - 1
	call VxLoadRom

	ret


section "VisDiverReset", rom0
;; @param HL: this VisDiver
VisDiverReset::
	xor a
	; y, x
	ld [hl+], a :: ld [hl+], a
	; ctl
	ld [hl+], a

	;
	ld [hl+], a :: ld [hl+], a

		push hl
	call AniInit
		pop hl

	ld de, VisDiver_aniMove.f2
	ld b, bank(VisDiver_aniMove)
	jp AniSetFrame


section "VisDiverSetState", rom0
;; @param HL: this VisDiver
VisDiverSetState::
	ret


section "VisDiverSetCtl", rom0
;; @param A: new ctl value
;; @param HL: this VisDiver
;; @mut: AF, BC, DE, HL
VisDiverSetCtl::
	ld bc, VisDiver_ctl
	add hl, bc

	ld c, a
	ld a, [hl]
	ld b, a

	; Speed
	ld a, c
	and VisDiverCtl_SPEED
	ld d, a
	call _SetSpeed

	; Heading
	call _SetHeading
	ld a, [hl]
	ld [hl], b
	; If X heading changed, set appropriate animation
	xor b
	and VisDiverDir_X
	ret z

	ld de, VisDiver_aniMove.left
	ld a, b
	and VisDiverDir_LEFT
	jr nz, :+
	ld de, VisDiver_aniMove.right
:
	ld bc, VisDiver_ani - VisDiver_ctl
	add hl, bc
	ld b, bank(VisDiver_aniMove)
	jp AniSetFrame

	ret


;; @param B: ctl state
;; @param D: target speed
;; @ret B: new ctl state
;; @mut: AF: B, D
_SetSpeed:
	ld a, d
	and a
	jr nz, :+
	; slowly to stop
	ld a, [wVBlankCount]
	and $07
	ret nz
:
	ld a, b
	and VisDiverCtl_SPEED

	cp d
	ret z
	sbc a :: cpl :: or 1
	add b
	ld b, a
	ret


;; @param B: ctl state
;; @param C: new heading
;; @ret B: new ctl state
_SetHeading:
	; Accept each axis independently & only accept non-zero values.
	ld a, c
	and VisDiverDir_X
	jr z, .do_y_maybe
	xor b
	and VisDiverDir_X
	xor b
	ld b, a

.do_y_maybe
	ld a, c
	and VisDiverDir_Y
	ret z
	xor b
	and VisDiverDir_Y
	xor b
	ld b, a

	ret


section "VisDiverUpdate", rom0
;; @param HL: this VisDiver
VisDiverUpdate::
	rombopen

	ld a, [hl+] :: ld b, a ; y
	ld a, [hl+] :: ld c, a ; x
	ld a, [hl+]
	and VisDiverCtl_SPEED
	ld d, a

		push bc

	assert VisDiver_ani - (VisDiver_ctl + 1) == 2
	inc hl :: inc hl
	call AniUpdate

	rombsel b

		pop bc

	; DE: Ani drawable pointer, abort if $FFFF
	ld a, e :: and d
	inc a
	ret z

	ld l, e :: ld h, d ; Copy Ani drawable to HL
	ld a, [wVisDiver_chri_move] :: ld d, a
	ld a, [wVisDiver_pal0] :: ld e, a

	jp SprxRenderMod

