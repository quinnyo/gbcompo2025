include "pack.rgbinc"
include "hardware.inc"
include "banker.rgbinc"
include "vis/widgets.rgbinc"


pushs "wPack", wram0
wPackWidth: db
wPackHeight: db
wPackCursorX: db
wPackCursorY: db
wPackCtl:: db
wPackHoldingItem: db
wPackPickedItem: db

pops ; wPack


pushs "wPackContents", wramx, align[8]
wPackContents:
	.item: ds PACK_MAX_ITEMS
	.x: ds PACK_MAX_ITEMS
	.y: ds PACK_MAX_ITEMS
	.dim: ds PACK_MAX_ITEMS
pops ; wPackContents


section "Pack", rom0
PackInit::
	ld hl, wPackWidth
	ld a, PACK_WIDTH_MAX :: ld [hl+], a
	ld a, PACK_HEIGHT_MAX :: ld [hl+], a
	xor a
	ld [hl+], a ; CursorX
	ld [hl+], a ; CursorY
	ld [hl+], a ; Ctl
	ld a, $FF
	ld [hl+], a ; HoldingItem
	ld [hl+], a ; PickedItem

		wrambpush bank(wPackContents)
	ld a, $FF
	ld c, sizeof("wPackContents")
	ld hl, startof("wPackContents")
	call MemFillSmall
		wrambpop

	call WidgetsInit

	ret


;; Call before making Pack visible.
PackPrepare::
	; DEBUG: Show *something* in Pack grid BG map
	ld hl, PACKVIEW_PACK_BG
	ld bc, (PACK_WIDTH_MAX << 8) | PACK_HEIGHT_MAX
	ld d, $03
	call FillBGRect

	ld hl, PACKVIEW_BGMAP
	ld bc, (PACKVIEW_WIDTH << 8) | PACKVIEW_HEIGHT
	ld d, $08 | 2
		ld a, 1 :: ldh [rVBK], a
	call FillBGRect
		xor a :: ldh [rVBK], a

	; begin open transition with window off screen
	ld a, 170 :: ld [wWX], a
	ld a, PACK_WY :: ld [wWY], a
	; show the window
	ld a, [wLCDC]
	or LCDCF_WINON | LCDCF_WIN9C00
	ld [wLCDC], a
	ret


;; @ret F.C: transition complete
;; @mut: AF
PackDrawerOpen::
	ld a, PACK_WY :: ld [wWY], a
	ld a, [wPackCtl]
	and PackCtl_OPEN
	jr nz, .finish
	ld a, [wWX]
	sub PACK_OPEN_DX
	cp PACK_WX + 1
	jr c, .finish
	ld [wWX], a
	and a ; ret F.NC
	ret
.finish
	ld a, [wPackCtl] :: or PackCtl_OPEN :: ld [wPackCtl], a
	ld a, PACK_WX :: ld [wWX], a
	scf ; ret F.C
	ret


;; @ret F.C: transition complete
;; @mut: AF
PackDrawerClose::
	ld a, [wPackCtl]
	and PackCtl_OPEN
	jr z, .finish
	ld a, [wWX]
	add PACK_CLOSE_DX
	cp 166
	jr nc, .finish
	ld [wWX], a
	and a ; ret F.NC
	ret
.finish
	ld a, 170
	ld [wWX], a
	ld [wWY], a
	; hide the window
	ld a, [wLCDC]
	and ~LCDCF_WINON
	ld [wLCDC], a
	ld a, [wPackCtl] :: and ~PackCtl_OPEN :: ld [wPackCtl], a
	scf ; ret F.C
	ret


PackProcess::
	; Draw cursor
	ld a, [wPackCursorX]
	add a :: add a :: add a ; mul 8
	add PACK_ORIGIN_X + PACK_CURSOR_OFFSET_X
	ld c, a
	ld a, [wPackCursorY]
	add a :: add a :: add a ; mul 8
	add PACK_ORIGIN_Y + PACK_CURSOR_OFFSET_Y
	ld b, a
	ld e, WIDGET_POINTER
	call WidgetRender

	ret


;; @param B: dir keys
;; @mut: AF, BC, DE, HL
PackCursorMove::
	; TODO: if HOLDING, shrink bounds by size of held item

	ld e, 0
	ld a, [wPackWidth] :: dec a :: ld d, a
	ld hl, wPackCursorX
	bit PADB_LEFT, b
	call nz, _CursorDec
	bit PADB_RIGHT, b
	call nz, _CursorInc

	ld a, [wPackHeight] :: dec a :: ld d, a
	ld hl, wPackCursorY
	bit PADB_UP, b
	call nz, _CursorDec
	bit PADB_DOWN, b
	call nz, _CursorInc

	ld a, [wPackCursorX] :: ld e, a
	ld a, [wPackCursorY] :: ld d, a
	call _QueryCell
	jr nc, .pick_none
	ld a, l :: ld [wPackPickedItem], a
	ld a, [wPackCtl]
	set bPackCtl_PICKED, a
	ld [wPackCtl], a

	ret

.pick_none:
	ld a, $FF :: ld [wPackPickedItem], a
	ld a, [wPackCtl]
	res bPackCtl_PICKED, a
	ld [wPackCtl], a
	ret


;; Check for item in cell
;; @param D,E: cell Y,X
;; @ret L: hit item index (if F.C)
;; @ret F.C: hit
;; @mut: AF, BC, HL
_QueryCell:
		wrambpush bank(wPackContents)

	ld b, CONTENTS_INDEX_MASK
	ld hl, wPackContents
.loop
	; get item dimensions
	ld a, l :: and b
	or low(wPackContents.dim) :: ld l, a
	ld c, [hl]

	; get item x position
	ld a, l :: and b
	or low(wPackContents.x) :: ld l, a
	; if itemX <= queryX
	ld a, e
	cp [hl]
	jr c, .next ; itemX > queryX

	; if (itemX + itemW - 1) < queryX
	ld a, c :: and $0F
	add [hl]
	cp e
	jr c, .next

	; get item y position
	ld a, l :: and b
	or low(wPackContents.y) :: ld l, a
	; if itemY <= queryY
	ld a, d
	cp [hl]
	jr c, .next ; itemY > queryY

	; if (itemY + itemH - 1) < queryY
	ld a, c :: swap a :: and $0F
	add [hl]
	cp d
	jr c, .next

	; hit!
	ld a, l :: and b :: ld l, a
		wrambpop
	scf ; return F.C
	ret

.next
	inc l
	ld a, l :: and b :: ld l, a
	jr nz, .loop
		wrambpop
	and a ; clear F.C
	ld l, $66
	ret


;; @param HL: pointer to value
;; @param E: min value (incl.)
_CursorDec:
	ld a, e
	cp [hl]
	jr c, :+
	; value <= min: clamp to min
	ld [hl], a
	ret
:
	; value > min: dec
	dec [hl]
	ret


;; @param HL: pointer to value
;; @param D: max value (incl.)
_CursorInc:
	ld a, [hl]
	cp d
	jr c, :+
	; value >= max: clamp to max
	ld [hl], d
	ret
:
	; value < max: inc
	inc [hl]
	ret


