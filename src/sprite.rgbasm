include "sprite.rgbinc"


def bFlipX equ 5
def bFlipY equ 6


section "Sprx", rom0
;; @param HL: Sprx to render
;; @param B,C: Y,X render position
;; @mut: AF, BC, DE, HL
SprxRender::
	ld a, b :: sub SprobOriginY :: ldh [hObModY], a
	ld a, c :: sub SprobOriginX :: ldh [hObModX], a

:
	; peek the first sprob byte
	bit bSprite_ESC, [hl]
	jr nz, .proc_esc
	ldh a, [hObModY] :: ld b, a
	ldh a, [hObModX] :: ld c, a
	call SprobRender
	jr :-

	ret
.proc_esc:
	; There's only one escape code: END -- terminate the sprite descriptor.
	ret


;; Render a sprite with modifier parameters.
;; @param HL: Sprx to render
;; @param B,C: Y,X render position
;; @param D: I mod
;; @param E: A mod (ADD the palette, XOR the rest)
;; @mut: AF, BC, DE, HL
SprxRenderMod::
	ld a, b :: ldh [hObModY], a
	ld a, c :: ldh [hObModX], a
	ld a, d :: ldh [hObModChri], a
	ld a, e :: ldh [hObModAtrb], a

;; SprxRenderMod but gets params straight from the `hObMod{Y,X,Chri,Atrb}` variables.
;; @param HL: Sprx to render
;; @mut: AF, BC, DE, HL
SprxRenderMod_ObMod::
	call ObdoCustomStartDE
.loop
	; peek the first sprob byte
	bit bSprite_ESC, [hl]
	jr nz, .proc_esc

	ldh a, [hObModAtrb] :: ld c, a

	; Y position, flip
	ldh a, [hObModY] :: ld b, a
	ld a, [hl+] :: sub SprobOriginY
	bit bFlipY, c
	jr z, :+
	cpl :: inc a
:
	add b
	ld [de], a :: inc de

	; X position, flip
	ldh a, [hObModX] :: ld b, a
	ld a, [hl+] :: sub SprobOriginX
	bit bFlipX, c
	jr z, :+
	cpl :: inc a
:
	add b
	ld [de], a :: inc de

	; CHRI
	ldh a, [hObModChri] :: ld b, a
	ld a, [hl+]
	add b
	ld [de], a :: inc de

	; ATRB
	; Palette mod gets added, rest of bits get xored.
	ld a, [hl+]
	ld b, a
	and $F8
	xor c
	ld c, a ; adjusted flags with palmod
	; add palmod
	add b
	; combine adjusted palette with adjusted flags
	xor c
	and $07
	xor c
	ld [de], a :: inc de

	jr .loop

.proc_esc:
	jp ObdoCustomEndDE


;; Performs the 'potential visibility' test at a screen-relative 16 bit position.
;; This determines if a sprite rendered at that position can possibly be visible.
;; Returns the result of the test and, if the result is positive,
;; the valid position ready to pass to one of the SprxRender functions.
;; @param BC: Y position in dots (signed, OBJ space)
;; @param DE: X position in dots (signed, OBJ space)
;; @ret B,C: Y,X valid sprx render position
;; @ret F.C: Set indicates positive result
;; @mut: AF, BC
SprxTestVisibility::
		push hl
	ld a, c :: add SprobOriginY :: ld l, a
	adc b :: sub l
	jr nz, .nope
	ld a, l
	cp 144 + 16 + SprobCoordMax
	jr nc, .nope

	ld a, e :: add SprobOriginX :: ld l, a
	adc d :: sub l
	jr nz, .nope
	ld a, l
	cp 160 + 8 + SprobCoordMax
	jr nc, .nope
		pop hl
	ld b, c
	ld c, e
	scf
	ret

.nope:
		pop hl
	and a ; clear F.C
	ret


;; Push one Sprob to OAM
;; @param HL: pointer to Sprob
;; @param B,C: Y,X Sprobspace origin
;; @ret HL: pointer at end of Sprob
;; @mut: AF, BC, DE, HL
SprobRender:
	ld a, [hl+] :: add b :: ld b, a
	ld a, [hl+] :: add c :: ld c, a
	ld a, [hl+] :: ld d, a
	ld a, [hl+] :: ld e, a
	push hl
	call ObdoSingle
	pop hl
	ret


/*
section "SprxTestSprxs", rom0
sprNil:
	db Sprite_END
spr1:
	; <0, 0> should be RenderPos - <32, 32>
	db 0, 0, 0, 1
	db 0, 63, 2, 2
	db 63, 63, 4, 3
	db 63, 0, 6, 4
	db Sprite_END
spr2:
	db 24 + 16, 24 + 8, 16, 0
	db 24 + 16, 32 + 8, 18, 0
	db Sprite_END
spr3:
	db 24 + 16, 24 + 8, 16, 1
	db 24 + 16, 32 + 8, 18, 2
	db Sprite_END
sprV:
	sprob_opts_reset sy:8, sx:1, si:1
	sprob_seq 8, -32, 0, 0, 0
	sprob_end
sprH:
	sprob_opts_reset sy:1, sx:8, si:1
	sprob_seq 8, 0, -32, 0, 1
	sprob_end


pushs "wTestEnt", wram0
wTestEntVY: dw
wTestEntVX: dw
wTestEntVSpr: dw
wTestEntHY: dw
wTestEntHX: dw
wTestEntHSpr: dw
pops


pushs "SprxTest", rom0
SprxTestInit::
	ld hl, startof("wTestEnt")
	ld c, sizeof("wTestEnt")
	xor a
	call MemFillSmall
	ld a, 48 :: ld [wTestEntVX + 0], a
	ld a, low(sprV) :: ld [wTestEntVSpr + 0], a
	ld a, high(sprV) :: ld [wTestEntVSpr + 1], a
	ld a, 152 :: ld [wTestEntHY + 0], a
	ld a, low(sprH) :: ld [wTestEntHSpr + 0], a
	ld a, high(sprH) :: ld [wTestEntHSpr + 1], a
	ret


SprxTestUpdate::
	ld hl, wTestEntVY
	call _TestMove
	ld hl, wTestEntVY
	call _TestEntRender
	ld hl, wTestEntHX
	call _TestMove
	ld hl, wTestEntHY
	call _TestEntRender
	ret


_TestMove:
	ld a, [hl+] :: ld c, a
	ld a, [hl-] :: ld b, a
	inc bc
	ld a, c :: ld [hl+], a
	ld a, b
	cp 5
	jr nz, :+
	ld bc, $FF00
	ld a, b
:
	ld [hl-], a
	ret


_TestEntRender:
	ld a, [wScroll.y + 0] :: ld e, a
	ld a, [wScroll.y + 1] :: ld d, a
	ld a, [hl+] :: sub e :: ld c, a
	ld a, [hl+] :: sbc d :: ld b, a

		push bc
	ld a, [wScroll.x + 0] :: ld c, a
	ld a, [wScroll.x + 1] :: ld b, a
	ld a, [hl+] :: sub c :: ld e, a
	ld a, [hl+] :: sbc b :: ld d, a
		pop bc

	; sprite pointer
	ld a, [hl+]
	ld h, [hl]
	ld l, a

	call SprxTestVisibility
	ret nc
	ld de, 0
	jp SprxRenderMod

pops
*/

